diff --git a/core/net/uip6.c b/core/net/uip6.c
index a588b3c..417f67b 100644
--- a/core/net/uip6.c
+++ b/core/net/uip6.c
@@ -79,6 +79,16 @@
 
 #include <string.h>
 
+#ifndef JENNIC_CONF_TIMESYNC
+# define USE_TS 0
+#else
+# define USE_TS JENNIC_CONF_TIMESYNC
+#endif
+
+#if USE_TS
+# include "hrclock.h"
+#endif
+
 /*---------------------------------------------------------------------------*/
 /* For Debug, logging, statistics                                            */
 /*---------------------------------------------------------------------------*/
@@ -163,6 +173,8 @@ u8_t uip_ext_opt_offset = 0;
 #define UIP_EXT_HDR_OPT_BUF            ((struct uip_ext_hdr_opt *)&uip_buf[uip_l2_l3_hdr_len + uip_ext_opt_offset])
 #define UIP_EXT_HDR_OPT_PADN_BUF  ((struct uip_ext_hdr_opt_padn *)&uip_buf[uip_l2_l3_hdr_len + uip_ext_opt_offset])
 #define UIP_ICMP6_ERROR_BUF            ((struct uip_icmp6_error *)&uip_buf[uip_l2_l3_icmp_hdr_len])
+
+
 /** @} */
 /** \name Buffer variables
  *  @{
@@ -1348,6 +1360,12 @@ uip_process(u8_t flag)
       UIP_STAT(++uip_stat.icmp.recv);
       uip_len = 0;
       break;
+#if USE_TS
+    case ICMP6_TIMESYNC:
+      clock_synchronize();
+      uip_len = 0;
+      break;
+#endif
     default:
       //PRINTF("Unknown icmp6 message type %d\n", UIP_ICMP_BUF->type);
       UIP_STAT(++uip_stat.icmp.drop);
diff --git a/cpu/jennic/Makefile.jn51xx b/cpu/jennic/Makefile.jn51xx
index 405c8da..cdf49e8 100644
--- a/cpu/jennic/Makefile.jn51xx
+++ b/cpu/jennic/Makefile.jn51xx
@@ -90,4 +90,5 @@ endif
 
 %.u: %.$(TARGET).hex
 	#sudo jenprog -c ftdi $<
-	jenprog $<
+	#jenprog $<
+	jenprog -t /dev/ttyACM0 $<
diff --git a/cpu/jennic/dev/cfs-fatfs.c b/cpu/jennic/dev/cfs-fatfs.c
new file mode 100644
index 0000000..6d8beac
--- /dev/null
+++ b/cpu/jennic/dev/cfs-fatfs.c
@@ -0,0 +1,110 @@
+#include "ff.h"
+#include "contiki.h"
+#include "cfs/cfs.h"
+
+#define FILE_TABLE_SIZE 5
+
+static uint8_t inited = 0;
+
+static FATFS fs;
+static FIL file_table[FILE_TABLE_SIZE];
+
+static int cfs_fatfs_init()
+{
+  uint8_t i;
+  /* mark files as empty */
+  for (i = 0; i < FILE_TABLE_SIZE; i++)
+    file_table[i].fs = NULL;
+  
+  /* mount fatfs */
+  if (!f_mount(0, &fs)) {
+    inited = 1;
+    return 0;
+  } else
+    return -1;
+}
+
+
+int cfs_open(const char *name, int flags)
+{
+  uint8_t i;
+
+  if (!inited)
+    cfs_fatfs_init();
+
+  for (i = 0; i < FILE_TABLE_SIZE; i++) {
+    if (file_table[i].fs == NULL) {
+      /* only read and write flag */
+      if (!f_open(&file_table[i], name, (flags & 0x3) | FA_OPEN_ALWAYS)) {
+        if (flags & 0x4) {
+          f_lseek(&file_table[i], f_size(&file_table[i]));
+        }
+        return i;
+      } else
+        return -1;
+    }
+  }
+  return -1;
+}
+
+void cfs_close(int fd)
+{
+  if (inited && file_table[fd].fs) {
+    f_close(&file_table[fd]);
+    file_table[fd].fs = NULL;
+  }
+}
+
+int cfs_read(int fd, void *buf, unsigned int len)
+{
+  if (inited && file_table[fd].fs) {
+    f_read(&file_table[fd], buf, len, &len);
+    return len;
+  }
+  return 0;
+}
+
+int cfs_write(int fd, const void *buf, unsigned int len)
+{
+  if (inited && file_table[fd].fs) {
+    f_write(&file_table[fd], buf, len, &len);
+    return len;
+  }
+  return 0; 
+}
+
+int cfs_seek(int fd, cfs_offset_t offset, int whence)
+{
+  uint32_t new_offset;
+  if (inited && file_table[fd].fs) {
+    switch (whence) {
+      case CFS_SEEK_CUR:
+        new_offset = f_tell(&file_table[fd]) + offset;
+        break;
+      case CFS_SEEK_END:
+        new_offset = f_size(&file_table[fd]) + offset;
+        break;
+      case CFS_SEEK_SET:
+      default:
+        new_offset = offset;
+        break;
+    }
+    f_lseek(&file_table[fd], new_offset);
+    return new_offset;
+  }
+  return 0;
+}
+
+
+/* dir functions not implemented */
+int cfs_opendir (struct cfs_dir *dirp, const char *name)
+{
+  return -1;
+}
+int cfs_readdir (struct cfs_dir *dirp, struct cfs_dirent *dirent)
+{
+  return -1;
+}
+void cfs_closedir (struct cfs_dir *dirp)
+{
+}
diff --git a/cpu/jennic/dev/clock.c b/cpu/jennic/dev/clock.c
index dcf015c..afa7156 100644
--- a/cpu/jennic/dev/clock.c
+++ b/cpu/jennic/dev/clock.c
@@ -30,6 +30,7 @@
  */
 
 #include <sys/clock.h>
+#include <sys/rtimer.h>
 #include <stdbool.h>
 #include <AppHardwareApi.h>
 #include "hrclock.h"
@@ -39,14 +40,33 @@
 #define TICKS_TO_USEC  (16)
 #define TICK_TIMER_MAX (0x0fffffff)
 
+/* enable/disable interrupts */
+#define ENABLE_INTERRUPTS();  {  register uint32 ru32CtrlReg; asm volatile ("l.mfspr %0, r0, 17;" :"=r"(ru32CtrlReg) : ); ru32CtrlReg |= 6; asm volatile ("l.mtspr r0, %0, 17;" : :"r"(ru32CtrlReg)); } 
+
+#define DISABLE_INTERRUPTS(); { register uint32 ru32CtrlReg; asm volatile ("l.mfspr %0, r0, 17;" :"=r"(ru32CtrlReg) : ); ru32CtrlReg &= 0xfffffff9; asm volatile ("l.mtspr r0, %0, 17;" : :"r"(ru32CtrlReg)); }
+
 static bool ticking = false;
+static uint32_t tick_timer_interval;
+static hrclock_t ticks = 0;
+static uint32_t last_tick = 0;
+
+void 
+tick_timer_int(uint32 u32Device, uint32 u32ItemBitmap)
+{
+  ticks += tick_timer_interval - last_tick;
+  last_tick = 0;
+  rtimer_run_next();
+}
 
 void
 clock_init()
 {
-  vAHI_TickTimerInterval(TICK_TIMER_MAX);
-  vAHI_TickTimerConfigure(E_AHI_TICK_TIMER_CONT);
+  tick_timer_interval = TICK_TIMER_MAX;
+  vAHI_TickTimerInterval(tick_timer_interval);
   vAHI_TickTimerWrite(0);
+  vAHI_TickTimerIntEnable(1);
+  vAHI_TickTimerRegisterCallback(&tick_timer_int);
+  vAHI_TickTimerConfigure(E_AHI_TICK_TIMER_RESTART);
   ticking = true;
 }
 
@@ -75,13 +95,76 @@ clock_delay(unsigned int i)
     ;
 }
 
+void 
+rtimer_arch_init()
+{
+}
+
+
+rtimer_clock_t 
+rtimer_arch_now()
+{
+  if(!ticking) clock_init();
+#ifdef JENNIC_CONF_TIMESYNC 
+  return clock_synced_hrtime()/(1000);
+#else
+  return clock_hrtime()/(1000);
+#endif
+}
+
+void
+rtimer_arch_schedule(rtimer_clock_t t)
+{
+  uint32_t temp_tick = u32AHI_TickTimerRead();
+#ifdef JENNIC_CONF_TIMESYNC 
+  hrclock_t usecs_required = (t * 1000) - clock_synced_hrtime();
+#else
+  hrclock_t usecs_required = (t * 1000) - clock_hrtime();
+#endif
+  uint32_t ticks_required = usecs_required * TICKS_TO_USEC;
+  tick_timer_interval = temp_tick + ticks_required;
+  vAHI_TickTimerInterval(tick_timer_interval);
+}
+
 /* return time in micro-seconds after this functions has completed. */
 hrclock_t
 clock_hrtime()
 {
-  static hrclock_t time = 0;
-  if(!ticking) clock_init();
-  time += u32AHI_TickTimerRead()/TICKS_TO_USEC;
-  vAHI_TickTimerWrite(4);
-  return time;
+  DISABLE_INTERRUPTS();
+  uint32_t temp_tick = u32AHI_TickTimerRead();
+  if (temp_tick > last_tick) {
+    ticks += (temp_tick - last_tick); 
+    last_tick = temp_tick;
+  } 
+  ENABLE_INTERRUPTS();
+  return ticks/TICKS_TO_USEC;
+}
+
+
+#ifdef JENNIC_CONF_TIMESYNC
+
+#include "uip.h"
+#include "ieee802.h"
+
+static uint8_t synced = 0;
+static hrclock_t offset = 0;
+uint8_t clock_synced()
+{
+  return synced;
 }
+
+hrclock_t clock_synced_hrtime()
+{
+  return clock_hrtime() + offset;
+}
+
+void clock_synchronize()
+{
+  synced = 1;
+  memcpy(&offset, UIP_ICMP6_TIMESTAMP, sizeof(hrclock_t));
+  offset = offset + 1800 - ieee_get_last_timestamp();   //offset = master_clock - recved_clock + time_delay
+  //printf("new offset\r\n");
+}
+
+#endif
+
diff --git a/cpu/jennic/dev/ff.c b/cpu/jennic/dev/ff.c
new file mode 100644
index 0000000..82f7898
--- /dev/null
+++ b/cpu/jennic/dev/ff.c
@@ -0,0 +1,4083 @@
+/*----------------------------------------------------------------------------/
+/  FatFs - FAT file system module  R0.09                  (C)ChaN, 2011
+/-----------------------------------------------------------------------------/
+/ FatFs module is a generic FAT file system module for small embedded systems.
+/ This is a free software that opened for education, research and commercial
+/ developments under license policy of following terms.
+/
+/  Copyright (C) 2011, ChaN, all right reserved.
+/
+/ * The FatFs module is a free software and there is NO WARRANTY.
+/ * No restriction on use. You can use, modify and redistribute it for
+/   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
+/ * Redistributions of source code must retain the above copyright notice.
+/
+/-----------------------------------------------------------------------------/
+/ Feb 26,'06 R0.00  Prototype.
+/
+/ Apr 29,'06 R0.01  First stable version.
+/
+/ Jun 01,'06 R0.02  Added FAT12 support.
+/                   Removed unbuffered mode.
+/                   Fixed a problem on small (<32M) partition.
+/ Jun 10,'06 R0.02a Added a configuration option (_FS_MINIMUM).
+/
+/ Sep 22,'06 R0.03  Added f_rename().
+/                   Changed option _FS_MINIMUM to _FS_MINIMIZE.
+/ Dec 11,'06 R0.03a Improved cluster scan algorithm to write files fast.
+/                   Fixed f_mkdir() creates incorrect directory on FAT32.
+/
+/ Feb 04,'07 R0.04  Supported multiple drive system.
+/                   Changed some interfaces for multiple drive system.
+/                   Changed f_mountdrv() to f_mount().
+/                   Added f_mkfs().
+/ Apr 01,'07 R0.04a Supported multiple partitions on a physical drive.
+/                   Added a capability of extending file size to f_lseek().
+/                   Added minimization level 3.
+/                   Fixed an endian sensitive code in f_mkfs().
+/ May 05,'07 R0.04b Added a configuration option _USE_NTFLAG.
+/                   Added FSInfo support.
+/                   Fixed DBCS name can result FR_INVALID_NAME.
+/                   Fixed short seek (<= csize) collapses the file object.
+/
+/ Aug 25,'07 R0.05  Changed arguments of f_read(), f_write() and f_mkfs().
+/                   Fixed f_mkfs() on FAT32 creates incorrect FSInfo.
+/                   Fixed f_mkdir() on FAT32 creates incorrect directory.
+/ Feb 03,'08 R0.05a Added f_truncate() and f_utime().
+/                   Fixed off by one error at FAT sub-type determination.
+/                   Fixed btr in f_read() can be mistruncated.
+/                   Fixed cached sector is not flushed when create and close without write.
+/
+/ Apr 01,'08 R0.06  Added fputc(), fputs(), fprintf() and fgets().
+/                   Improved performance of f_lseek() on moving to the same or following cluster.
+/
+/ Apr 01,'09 R0.07  Merged Tiny-FatFs as a configuration option. (_FS_TINY)
+/                   Added long file name feature.
+/                   Added multiple code page feature.
+/                   Added re-entrancy for multitask operation.
+/                   Added auto cluster size selection to f_mkfs().
+/                   Added rewind option to f_readdir().
+/                   Changed result code of critical errors.
+/                   Renamed string functions to avoid name collision.
+/ Apr 14,'09 R0.07a Separated out OS dependent code on reentrant cfg.
+/                   Added multiple sector size feature.
+/ Jun 21,'09 R0.07c Fixed f_unlink() can return FR_OK on error.
+/                   Fixed wrong cache control in f_lseek().
+/                   Added relative path feature.
+/                   Added f_chdir() and f_chdrive().
+/                   Added proper case conversion to extended char.
+/ Nov 03,'09 R0.07e Separated out configuration options from ff.h to ffconf.h.
+/                   Fixed f_unlink() fails to remove a sub-dir on _FS_RPATH.
+/                   Fixed name matching error on the 13 char boundary.
+/                   Added a configuration option, _LFN_UNICODE.
+/                   Changed f_readdir() to return the SFN with always upper case on non-LFN cfg.
+/
+/ May 15,'10 R0.08  Added a memory configuration option. (_USE_LFN = 3)
+/                   Added file lock feature. (_FS_SHARE)
+/                   Added fast seek feature. (_USE_FASTSEEK)
+/                   Changed some types on the API, XCHAR->TCHAR.
+/                   Changed fname member in the FILINFO structure on Unicode cfg.
+/                   String functions support UTF-8 encoding files on Unicode cfg.
+/ Aug 16,'10 R0.08a Added f_getcwd(). (_FS_RPATH = 2)
+/                   Added sector erase feature. (_USE_ERASE)
+/                   Moved file lock semaphore table from fs object to the bss.
+/                   Fixed a wrong directory entry is created on non-LFN cfg when the given name contains ';'.
+/                   Fixed f_mkfs() creates wrong FAT32 volume.
+/ Jan 15,'11 R0.08b Fast seek feature is also applied to f_read() and f_write().
+/                   f_lseek() reports required table size on creating CLMP.
+/                   Extended format syntax of f_printf function.
+/                   Ignores duplicated directory separators in given path names.
+/
+/ Sep 06,'11 R0.09  f_mkfs() supports multiple partition to finish the multiple partition feature.
+/                   Added f_fdisk(). (_MULTI_PARTITION = 2)
+/---------------------------------------------------------------------------*/
+
+#include "ff.h"			/* FatFs configurations and declarations */
+#include "sd.h"		/* Declarations of low level disk I/O functions */
+
+
+/*--------------------------------------------------------------------------
+
+   Module Private Definitions
+
+---------------------------------------------------------------------------*/
+
+#if _FATFS != 6502	/* Revision ID */
+#error Wrong include file (ff.h). 
+#endif
+
+
+/* Definitions on sector size */
+#if _MAX_SS != 512 && _MAX_SS != 1024 && _MAX_SS != 2048 && _MAX_SS != 4096
+#error Wrong sector size.
+#endif
+#if _MAX_SS != 512
+#define	SS(fs)	((fs)->ssize)	/* Variable sector size */
+#else
+#define	SS(fs)	512U			/* Fixed sector size */
+#endif
+
+
+/* Reentrancy related */
+#if _FS_REENTRANT
+#if _USE_LFN == 1
+#error Static LFN work area must not be used in re-entrant configuration.
+#endif
+#define	ENTER_FF(fs)		{ if (!lock_fs(fs)) return FR_TIMEOUT; }
+#define	LEAVE_FF(fs, res)	{ unlock_fs(fs, res); return res; }
+#else
+#define	ENTER_FF(fs)
+#define LEAVE_FF(fs, res)	return res
+#endif
+
+#define	ABORT(fs, res)		{ fp->flag |= FA__ERROR; LEAVE_FF(fs, res); }
+
+
+/* File shareing feature */
+#if _FS_SHARE
+#if _FS_READONLY
+#error _FS_SHARE must be 0 on read-only cfg.
+#endif
+typedef struct {
+	FATFS *fs;				/* File ID 1, volume (NULL:blank entry) */
+	DWORD clu;				/* File ID 2, directory */
+	WORD idx;				/* File ID 3, directory index */
+	WORD ctr;				/* File open counter, 0:none, 0x01..0xFF:read open count, 0x100:write mode */
+} FILESEM;
+#endif
+
+
+/* Misc definitions */
+#define LD_CLUST(dir)	(((DWORD)LD_WORD(dir+DIR_FstClusHI)<<16) | LD_WORD(dir+DIR_FstClusLO))
+#define ST_CLUST(dir,cl) {ST_WORD(dir+DIR_FstClusLO, cl); ST_WORD(dir+DIR_FstClusHI, (DWORD)cl>>16);}
+
+
+/* DBCS code ranges and SBCS extend char conversion table */
+
+#if _CODE_PAGE == 932	/* Japanese Shift-JIS */
+#define _DF1S	0x81	/* DBC 1st byte range 1 start */
+#define _DF1E	0x9F	/* DBC 1st byte range 1 end */
+#define _DF2S	0xE0	/* DBC 1st byte range 2 start */
+#define _DF2E	0xFC	/* DBC 1st byte range 2 end */
+#define _DS1S	0x40	/* DBC 2nd byte range 1 start */
+#define _DS1E	0x7E	/* DBC 2nd byte range 1 end */
+#define _DS2S	0x80	/* DBC 2nd byte range 2 start */
+#define _DS2E	0xFC	/* DBC 2nd byte range 2 end */
+
+#elif _CODE_PAGE == 936	/* Simplified Chinese GBK */
+#define _DF1S	0x81
+#define _DF1E	0xFE
+#define _DS1S	0x40
+#define _DS1E	0x7E
+#define _DS2S	0x80
+#define _DS2E	0xFE
+
+#elif _CODE_PAGE == 949	/* Korean */
+#define _DF1S	0x81
+#define _DF1E	0xFE
+#define _DS1S	0x41
+#define _DS1E	0x5A
+#define _DS2S	0x61
+#define _DS2E	0x7A
+#define _DS3S	0x81
+#define _DS3E	0xFE
+
+#elif _CODE_PAGE == 950	/* Traditional Chinese Big5 */
+#define _DF1S	0x81
+#define _DF1E	0xFE
+#define _DS1S	0x40
+#define _DS1E	0x7E
+#define _DS2S	0xA1
+#define _DS2E	0xFE
+
+#elif _CODE_PAGE == 437	/* U.S. (OEM) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F,0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
+				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+
+#elif _CODE_PAGE == 720	/* Arabic (OEM) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x81,0x45,0x41,0x84,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x49,0x49,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
+				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+
+#elif _CODE_PAGE == 737	/* Greek (OEM) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x96,0x97,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87, \
+				0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xE7,0xE8,0xF1,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+
+#elif _CODE_PAGE == 775	/* Baltic (OEM) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0x95,0x96,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
+				0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xA5,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+
+#elif _CODE_PAGE == 850	/* Multilingual Latin 1 (OEM) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
+				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+
+#elif _CODE_PAGE == 852	/* Latin 2 (OEM) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F,0x90,0x91,0x91,0xE2,0x99,0x95,0x95,0x97,0x97,0x99,0x9A,0x9B,0x9B,0x9D,0x9E,0x9F, \
+				0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBD,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD2,0xD5,0xD6,0xD7,0xB7,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xEB,0xFC,0xFC,0xFE,0xFF}
+
+#elif _CODE_PAGE == 855	/* Cyrillic (OEM) */
+#define _DF1S	0
+#define _EXCVT {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F,0x91,0x91,0x93,0x93,0x95,0x95,0x97,0x97,0x99,0x99,0x9B,0x9B,0x9D,0x9D,0x9F,0x9F, \
+				0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB6,0xB6,0xB8,0xB8,0xB9,0xBA,0xBB,0xBC,0xBE,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD3,0xD3,0xD5,0xD5,0xD7,0xD7,0xDD,0xD9,0xDA,0xDB,0xDC,0xDD,0xE0,0xDF, \
+				0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFD,0xFE,0xFF}
+
+#elif _CODE_PAGE == 857	/* Turkish (OEM) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x98,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x98,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9E, \
+				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0x59,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+
+#elif _CODE_PAGE == 858	/* Multilingual Latin 1 + Euro (OEM) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
+				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+
+#elif _CODE_PAGE == 862	/* Hebrew (OEM) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
+				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+
+#elif _CODE_PAGE == 866	/* Russian (OEM) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
+				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0x90,0x91,0x92,0x93,0x9d,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+
+#elif _CODE_PAGE == 874	/* Thai (OEM, Windows) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
+				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+
+#elif _CODE_PAGE == 1250 /* Central Europe (Windows) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
+				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xA3,0xB4,0xB5,0xB6,0xB7,0xB8,0xA5,0xAA,0xBB,0xBC,0xBD,0xBC,0xAF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
+
+#elif _CODE_PAGE == 1251 /* Cyrillic (Windows) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x81,0x82,0x82,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x80,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
+				0xA0,0xA2,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB2,0xA5,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xA3,0xBD,0xBD,0xAF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF}
+
+#elif _CODE_PAGE == 1252 /* Latin 1 (Windows) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0xAd,0x9B,0x8C,0x9D,0xAE,0x9F, \
+				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
+
+#elif _CODE_PAGE == 1253 /* Greek (Windows) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
+				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xA2,0xB8,0xB9,0xBA, \
+				0xE0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xFB,0xBC,0xFD,0xBF,0xFF}
+
+#elif _CODE_PAGE == 1254 /* Turkish (Windows) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x9D,0x9E,0x9F, \
+				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
+
+#elif _CODE_PAGE == 1255 /* Hebrew (Windows) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
+				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
+
+#elif _CODE_PAGE == 1256 /* Arabic (Windows) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x8C,0x9D,0x9E,0x9F, \
+				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0x41,0xE1,0x41,0xE3,0xE4,0xE5,0xE6,0x43,0x45,0x45,0x45,0x45,0xEC,0xED,0x49,0x49,0xF0,0xF1,0xF2,0xF3,0x4F,0xF5,0xF6,0xF7,0xF8,0x55,0xFA,0x55,0x55,0xFD,0xFE,0xFF}
+
+#elif _CODE_PAGE == 1257 /* Baltic (Windows) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
+				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xBC,0xBD,0xBE,0xAF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
+
+#elif _CODE_PAGE == 1258 /* Vietnam (OEM, Windows) */
+#define _DF1S	0
+#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0xAC,0x9D,0x9E,0x9F, \
+				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
+				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xEC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xFE,0x9F}
+
+#elif _CODE_PAGE == 1	/* ASCII (for only non-LFN cfg) */
+#if _USE_LFN
+#error Cannot use LFN feature without valid code page.
+#endif
+#define _DF1S	0
+
+#else
+#error Unknown code page
+
+#endif
+
+
+/* Character code support macros */
+#define IsUpper(c)	(((c)>='A')&&((c)<='Z'))
+#define IsLower(c)	(((c)>='a')&&((c)<='z'))
+#define IsDigit(c)	(((c)>='0')&&((c)<='9'))
+
+#if _DF1S		/* Code page is DBCS */
+
+#ifdef _DF2S	/* Two 1st byte areas */
+#define IsDBCS1(c)	(((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E) || ((BYTE)(c) >= _DF2S && (BYTE)(c) <= _DF2E))
+#else			/* One 1st byte area */
+#define IsDBCS1(c)	((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E)
+#endif
+
+#ifdef _DS3S	/* Three 2nd byte areas */
+#define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E) || ((BYTE)(c) >= _DS3S && (BYTE)(c) <= _DS3E))
+#else			/* Two 2nd byte areas */
+#define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E))
+#endif
+
+#else			/* Code page is SBCS */
+
+#define IsDBCS1(c)	0
+#define IsDBCS2(c)	0
+
+#endif /* _DF1S */
+
+
+/* Name status flags */
+#define NS			11		/* Index of name status byte in fn[] */
+#define NS_LOSS		0x01	/* Out of 8.3 format */
+#define NS_LFN		0x02	/* Force to create LFN entry */
+#define NS_LAST		0x04	/* Last segment */
+#define NS_BODY		0x08	/* Lower case flag (body) */
+#define NS_EXT		0x10	/* Lower case flag (ext) */
+#define NS_DOT		0x20	/* Dot entry */
+
+
+/* FAT sub-type boundaries */
+/* Note that the FAT spec by Microsoft says 4085 but Windows works with 4087! */
+#define MIN_FAT16	4086	/* Minimum number of clusters for FAT16 */
+#define	MIN_FAT32	65526	/* Minimum number of clusters for FAT32 */
+
+
+/* FatFs refers the members in the FAT structures as byte array instead of
+/ structure member because the structure is not binary compatible between
+/ different platforms */
+
+#define BS_jmpBoot			0	/* Jump instruction (3) */
+#define BS_OEMName			3	/* OEM name (8) */
+#define BPB_BytsPerSec		11	/* Sector size [byte] (2) */
+#define BPB_SecPerClus		13	/* Cluster size [sector] (1) */
+#define BPB_RsvdSecCnt		14	/* Size of reserved area [sector] (2) */
+#define BPB_NumFATs			16	/* Number of FAT copies (1) */
+#define BPB_RootEntCnt		17	/* Number of root dir entries for FAT12/16 (2) */
+#define BPB_TotSec16		19	/* Volume size [sector] (2) */
+#define BPB_Media			21	/* Media descriptor (1) */
+#define BPB_FATSz16			22	/* FAT size [sector] (2) */
+#define BPB_SecPerTrk		24	/* Track size [sector] (2) */
+#define BPB_NumHeads		26	/* Number of heads (2) */
+#define BPB_HiddSec			28	/* Number of special hidden sectors (4) */
+#define BPB_TotSec32		32	/* Volume size [sector] (4) */
+#define BS_DrvNum			36	/* Physical drive number (2) */
+#define BS_BootSig			38	/* Extended boot signature (1) */
+#define BS_VolID			39	/* Volume serial number (4) */
+#define BS_VolLab			43	/* Volume label (8) */
+#define BS_FilSysType		54	/* File system type (1) */
+#define BPB_FATSz32			36	/* FAT size [sector] (4) */
+#define BPB_ExtFlags		40	/* Extended flags (2) */
+#define BPB_FSVer			42	/* File system version (2) */
+#define BPB_RootClus		44	/* Root dir first cluster (4) */
+#define BPB_FSInfo			48	/* Offset of FSInfo sector (2) */
+#define BPB_BkBootSec		50	/* Offset of backup boot sectot (2) */
+#define BS_DrvNum32			64	/* Physical drive number (2) */
+#define BS_BootSig32		66	/* Extended boot signature (1) */
+#define BS_VolID32			67	/* Volume serial number (4) */
+#define BS_VolLab32			71	/* Volume label (8) */
+#define BS_FilSysType32		82	/* File system type (1) */
+#define	FSI_LeadSig			0	/* FSI: Leading signature (4) */
+#define	FSI_StrucSig		484	/* FSI: Structure signature (4) */
+#define	FSI_Free_Count		488	/* FSI: Number of free clusters (4) */
+#define	FSI_Nxt_Free		492	/* FSI: Last allocated cluster (4) */
+#define MBR_Table			446	/* MBR: Partition table offset (2) */
+#define	SZ_PTE				16	/* MBR: Size of a partition table entry */
+#define BS_55AA				510	/* Boot sector signature (2) */
+
+#define	DIR_Name			0	/* Short file name (11) */
+#define	DIR_Attr			11	/* Attribute (1) */
+#define	DIR_NTres			12	/* NT flag (1) */
+#define	DIR_CrtTime			14	/* Created time (2) */
+#define	DIR_CrtDate			16	/* Created date (2) */
+#define	DIR_FstClusHI		20	/* Higher 16-bit of first cluster (2) */
+#define	DIR_WrtTime			22	/* Modified time (2) */
+#define	DIR_WrtDate			24	/* Modified date (2) */
+#define	DIR_FstClusLO		26	/* Lower 16-bit of first cluster (2) */
+#define	DIR_FileSize		28	/* File size (4) */
+#define	LDIR_Ord			0	/* LFN entry order and LLE flag (1) */
+#define	LDIR_Attr			11	/* LFN attribute (1) */
+#define	LDIR_Type			12	/* LFN type (1) */
+#define	LDIR_Chksum			13	/* Sum of corresponding SFN entry */
+#define	LDIR_FstClusLO		26	/* Filled by zero (0) */
+#define	SZ_DIR				32		/* Size of a directory entry */
+#define	LLE					0x40	/* Last long entry flag in LDIR_Ord */
+#define	DDE					0xE5	/* Deleted directory enrty mark in DIR_Name[0] */
+#define	NDDE				0x05	/* Replacement of a character collides with DDE */
+
+
+/*------------------------------------------------------------*/
+/* Module private work area                                   */
+/*------------------------------------------------------------*/
+/* Note that uninitialized variables with static duration are
+/  zeroed/nulled at start-up. If not, the compiler or start-up
+/  routine is out of ANSI-C standard.
+*/
+
+#if _VOLUMES
+static
+FATFS *FatFs[_VOLUMES];	/* Pointer to the file system objects (logical drives) */
+#else
+#error Number of volumes must not be 0.
+#endif
+
+static
+WORD Fsid;				/* File system mount ID */
+
+#if _FS_RPATH
+static
+BYTE CurrVol;			/* Current drive */
+#endif
+
+#if _FS_SHARE
+static
+FILESEM	Files[_FS_SHARE];	/* File lock semaphores */
+#endif
+
+#if _USE_LFN == 0			/* No LFN feature */
+#define	DEF_NAMEBUF			BYTE sfn[12]
+#define INIT_BUF(dobj)		(dobj).fn = sfn
+#define	FREE_BUF()
+
+#elif _USE_LFN == 1			/* LFN feature with static working buffer */
+static WCHAR LfnBuf[_MAX_LFN+1];
+#define	DEF_NAMEBUF			BYTE sfn[12]
+#define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = LfnBuf; }
+#define	FREE_BUF()
+
+#elif _USE_LFN == 2 		/* LFN feature with dynamic working buffer on the stack */
+#define	DEF_NAMEBUF			BYTE sfn[12]; WCHAR lbuf[_MAX_LFN+1]
+#define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = lbuf; }
+#define	FREE_BUF()
+
+#elif _USE_LFN == 3 		/* LFN feature with dynamic working buffer on the heap */
+#define	DEF_NAMEBUF			BYTE sfn[12]; WCHAR *lfn
+#define INIT_BUF(dobj)		{ lfn = ff_memalloc((_MAX_LFN + 1) * 2); \
+							  if (!lfn) LEAVE_FF((dobj).fs, FR_NOT_ENOUGH_CORE); \
+							  (dobj).lfn = lfn;	(dobj).fn = sfn; }
+#define	FREE_BUF()			ff_memfree(lfn)
+
+#else
+#error Wrong LFN configuration.
+#endif
+
+
+
+
+/*--------------------------------------------------------------------------
+
+   Module Private Functions
+
+---------------------------------------------------------------------------*/
+
+
+/*-----------------------------------------------------------------------*/
+/* String functions                                                      */
+/*-----------------------------------------------------------------------*/
+
+/* Copy memory to memory */
+static
+void mem_cpy (void* dst, const void* src, UINT cnt) {
+	BYTE *d = (BYTE*)dst;
+	const BYTE *s = (const BYTE*)src;
+
+#if _WORD_ACCESS == 1
+	while (cnt >= sizeof(int)) {
+		*(int*)d = *(int*)s;
+		d += sizeof(int); s += sizeof(int);
+		cnt -= sizeof(int);
+	}
+#endif
+	while (cnt--)
+		*d++ = *s++;
+}
+
+/* Fill memory */
+static
+void mem_set (void* dst, int val, UINT cnt) {
+	BYTE *d = (BYTE*)dst;
+
+	while (cnt--)
+		*d++ = (BYTE)val;
+}
+
+/* Compare memory to memory */
+static
+int mem_cmp (const void* dst, const void* src, UINT cnt) {
+	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
+	int r = 0;
+
+	while (cnt-- && (r = *d++ - *s++) == 0) ;
+	return r;
+}
+
+/* Check if chr is contained in the string */
+static
+int chk_chr (const char* str, int chr) {
+	while (*str && *str != chr) str++;
+	return *str;
+}
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Request/Release grant to access the volume                            */
+/*-----------------------------------------------------------------------*/
+#if _FS_REENTRANT
+
+static
+int lock_fs (
+	FATFS *fs		/* File system object */
+)
+{
+	return ff_req_grant(fs->sobj);
+}
+
+
+static
+void unlock_fs (
+	FATFS *fs,		/* File system object */
+	FRESULT res		/* Result code to be returned */
+)
+{
+	if (res != FR_NOT_ENABLED &&
+		res != FR_INVALID_DRIVE &&
+		res != FR_INVALID_OBJECT &&
+		res != FR_TIMEOUT) {
+		ff_rel_grant(fs->sobj);
+	}
+}
+#endif
+
+
+
+/*-----------------------------------------------------------------------*/
+/* File shareing control functions                                       */
+/*-----------------------------------------------------------------------*/
+#if _FS_SHARE
+
+static
+FRESULT chk_lock (	/* Check if the file can be accessed */
+	DIR* dj,		/* Directory object pointing the file to be checked */
+	int acc			/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
+)
+{
+	UINT i, be;
+
+	/* Search file semaphore table */
+	for (i = be = 0; i < _FS_SHARE; i++) {
+		if (Files[i].fs) {	/* Existing entry */
+			if (Files[i].fs == dj->fs &&	 	/* Check if the file matched with an open file */
+				Files[i].clu == dj->sclust &&
+				Files[i].idx == dj->index) break;
+		} else {			/* Blank entry */
+			be++;
+		}
+	}
+	if (i == _FS_SHARE)	/* The file is not opened */
+		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new file? */
+
+	/* The file has been opened. Reject any open against writing file and all write mode open */
+	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
+}
+
+
+static
+int enq_lock (void)	/* Check if an entry is available for a new file */
+{
+	UINT i;
+
+	for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
+	return (i == _FS_SHARE) ? 0 : 1;
+}
+
+
+static
+UINT inc_lock (	/* Increment file open counter and returns its index (0:int error) */
+	DIR* dj,	/* Directory object pointing the file to register or increment */
+	int acc		/* Desired access mode (0:Read, !0:Write) */
+)
+{
+	UINT i;
+
+
+	for (i = 0; i < _FS_SHARE; i++) {	/* Find the file */
+		if (Files[i].fs == dj->fs &&
+			Files[i].clu == dj->sclust &&
+			Files[i].idx == dj->index) break;
+	}
+
+	if (i == _FS_SHARE) {				/* Not opened. Register it as new. */
+		for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
+		if (i == _FS_SHARE) return 0;	/* No space to register (int err) */
+		Files[i].fs = dj->fs;
+		Files[i].clu = dj->sclust;
+		Files[i].idx = dj->index;
+		Files[i].ctr = 0;
+	}
+
+	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
+
+	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
+
+	return i + 1;
+}
+
+
+static
+FRESULT dec_lock (	/* Decrement file open counter */
+	UINT i			/* Semaphore index */
+)
+{
+	WORD n;
+	FRESULT res;
+
+
+	if (--i < _FS_SHARE) {
+		n = Files[i].ctr;
+		if (n == 0x100) n = 0;
+		if (n) n--;
+		Files[i].ctr = n;
+		if (!n) Files[i].fs = 0;
+		res = FR_OK;
+	} else {
+		res = FR_INT_ERR;
+	}
+	return res;
+}
+
+
+static
+void clear_lock (	/* Clear lock entries of the volume */
+	FATFS *fs
+)
+{
+	UINT i;
+
+	for (i = 0; i < _FS_SHARE; i++) {
+		if (Files[i].fs == fs) Files[i].fs = 0;
+	}
+}
+#endif
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Change window offset                                                  */
+/*-----------------------------------------------------------------------*/
+
+static
+FRESULT move_window (
+	FATFS *fs,		/* File system object */
+	DWORD sector	/* Sector number to make appearance in the fs->win[] */
+)					/* Move to zero only writes back dirty window */
+{
+	DWORD wsect;
+
+
+	wsect = fs->winsect;
+	if (wsect != sector) {	/* Changed current window */
+#if !_FS_READONLY
+		if (fs->wflag) {	/* Write back dirty window if needed */
+			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
+				return FR_DISK_ERR;
+			fs->wflag = 0;
+			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
+				BYTE nf;
+				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
+					wsect += fs->fsize;
+					disk_write(fs->drv, fs->win, wsect, 1);
+				}
+			}
+		}
+#endif
+		if (sector) {
+			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
+				return FR_DISK_ERR;
+			fs->winsect = sector;
+		}
+	}
+
+	return FR_OK;
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Clean-up cached data                                                  */
+/*-----------------------------------------------------------------------*/
+#if !_FS_READONLY
+static
+FRESULT sync (	/* FR_OK: successful, FR_DISK_ERR: failed */
+	FATFS *fs	/* File system object */
+)
+{
+	FRESULT res;
+
+
+	res = move_window(fs, 0);
+	if (res == FR_OK) {
+		/* Update FSInfo sector if needed */
+		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
+			fs->winsect = 0;
+			/* Create FSInfo structure */
+			mem_set(fs->win, 0, 512);
+			ST_WORD(fs->win+BS_55AA, 0xAA55);
+			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
+			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
+			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
+			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
+			/* Write it into the FSInfo sector */
+			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
+			fs->fsi_flag = 0;
+		}
+		/* Make sure that no pending write process in the physical drive */
+		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
+			res = FR_DISK_ERR;
+	}
+
+	return res;
+}
+#endif
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Get sector# from cluster#                                             */
+/*-----------------------------------------------------------------------*/
+
+
+DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
+	FATFS *fs,		/* File system object */
+	DWORD clst		/* Cluster# to be converted */
+)
+{
+	clst -= 2;
+	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
+	return clst * fs->csize + fs->database;
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* FAT access - Read value of a FAT entry                                */
+/*-----------------------------------------------------------------------*/
+
+
+DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
+	FATFS *fs,	/* File system object */
+	DWORD clst	/* Cluster# to get the link information */
+)
+{
+	UINT wc, bc;
+	BYTE *p;
+
+
+	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
+		return 1;
+
+	switch (fs->fs_type) {
+	case FS_FAT12 :
+		bc = (UINT)clst; bc += bc / 2;
+		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
+		wc = fs->win[bc % SS(fs)]; bc++;
+		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
+		wc |= fs->win[bc % SS(fs)] << 8;
+		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
+
+	case FS_FAT16 :
+		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
+		p = &fs->win[clst * 2 % SS(fs)];
+		return LD_WORD(p);
+
+	case FS_FAT32 :
+		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
+		p = &fs->win[clst * 4 % SS(fs)];
+		return LD_DWORD(p) & 0x0FFFFFFF;
+	}
+
+	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* FAT access - Change value of a FAT entry                              */
+/*-----------------------------------------------------------------------*/
+#if !_FS_READONLY
+
+FRESULT put_fat (
+	FATFS *fs,	/* File system object */
+	DWORD clst,	/* Cluster# to be changed in range of 2 to fs->n_fatent - 1 */
+	DWORD val	/* New value to mark the cluster */
+)
+{
+	UINT bc;
+	BYTE *p;
+	FRESULT res;
+
+
+	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
+		res = FR_INT_ERR;
+
+	} else {
+		switch (fs->fs_type) {
+		case FS_FAT12 :
+			bc = clst; bc += bc / 2;
+			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
+			if (res != FR_OK) break;
+			p = &fs->win[bc % SS(fs)];
+			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
+			bc++;
+			fs->wflag = 1;
+			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
+			if (res != FR_OK) break;
+			p = &fs->win[bc % SS(fs)];
+			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
+			break;
+
+		case FS_FAT16 :
+			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
+			if (res != FR_OK) break;
+			p = &fs->win[clst * 2 % SS(fs)];
+			ST_WORD(p, (WORD)val);
+			break;
+
+		case FS_FAT32 :
+			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
+			if (res != FR_OK) break;
+			p = &fs->win[clst * 4 % SS(fs)];
+			val |= LD_DWORD(p) & 0xF0000000;
+			ST_DWORD(p, val);
+			break;
+
+		default :
+			res = FR_INT_ERR;
+		}
+		fs->wflag = 1;
+	}
+
+	return res;
+}
+#endif /* !_FS_READONLY */
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* FAT handling - Remove a cluster chain                                 */
+/*-----------------------------------------------------------------------*/
+#if !_FS_READONLY
+static
+FRESULT remove_chain (
+	FATFS *fs,			/* File system object */
+	DWORD clst			/* Cluster# to remove a chain from */
+)
+{
+	FRESULT res;
+	DWORD nxt;
+#if _USE_ERASE
+	DWORD scl = clst, ecl = clst, resion[2];
+#endif
+
+	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
+		res = FR_INT_ERR;
+
+	} else {
+		res = FR_OK;
+		while (clst < fs->n_fatent) {			/* Not a last link? */
+			nxt = get_fat(fs, clst);			/* Get cluster status */
+			if (nxt == 0) break;				/* Empty cluster? */
+			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
+			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
+			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
+			if (res != FR_OK) break;
+			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
+				fs->free_clust++;
+				fs->fsi_flag = 1;
+			}
+#if _USE_ERASE
+			if (ecl + 1 == nxt) {	/* Next cluster is contiguous */
+				ecl = nxt;
+			} else {				/* End of contiguous clusters */ 
+				resion[0] = clust2sect(fs, scl);					/* Start sector */
+				resion[1] = clust2sect(fs, ecl) + fs->csize - 1;	/* End sector */
+				disk_ioctl(fs->drv, CTRL_ERASE_SECTOR, resion);		/* Erase the block */
+				scl = ecl = nxt;
+			}
+#endif
+			clst = nxt;	/* Next cluster */
+		}
+	}
+
+	return res;
+}
+#endif
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* FAT handling - Stretch or Create a cluster chain                      */
+/*-----------------------------------------------------------------------*/
+#if !_FS_READONLY
+static
+DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
+	FATFS *fs,			/* File system object */
+	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
+)
+{
+	DWORD cs, ncl, scl;
+	FRESULT res;
+
+
+	if (clst == 0) {		/* Create a new chain */
+		scl = fs->last_clust;			/* Get suggested start point */
+		if (!scl || scl >= fs->n_fatent) scl = 1;
+	}
+	else {					/* Stretch the current chain */
+		cs = get_fat(fs, clst);			/* Check the cluster status */
+		if (cs < 2) return 1;			/* It is an invalid cluster */
+		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
+		scl = clst;
+	}
+
+	ncl = scl;				/* Start cluster */
+	for (;;) {
+		ncl++;							/* Next cluster */
+		if (ncl >= fs->n_fatent) {		/* Wrap around */
+			ncl = 2;
+			if (ncl > scl) return 0;	/* No free cluster */
+		}
+		cs = get_fat(fs, ncl);			/* Get the cluster status */
+		if (cs == 0) break;				/* Found a free cluster */
+		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
+			return cs;
+		if (ncl == scl) return 0;		/* No free cluster */
+	}
+
+	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
+	if (res == FR_OK && clst != 0) {
+		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
+	}
+	if (res == FR_OK) {
+		fs->last_clust = ncl;			/* Update FSINFO */
+		if (fs->free_clust != 0xFFFFFFFF) {
+			fs->free_clust--;
+			fs->fsi_flag = 1;
+		}
+	} else {
+		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
+	}
+
+	return ncl;		/* Return new cluster number or error code */
+}
+#endif /* !_FS_READONLY */
+
+
+
+/*-----------------------------------------------------------------------*/
+/* FAT handling - Convert offset into cluster with link map table        */
+/*-----------------------------------------------------------------------*/
+
+#if _USE_FASTSEEK
+static
+DWORD clmt_clust (	/* <2:Error, >=2:Cluster number */
+	FIL* fp,		/* Pointer to the file object */
+	DWORD ofs		/* File offset to be converted to cluster# */
+)
+{
+	DWORD cl, ncl, *tbl;
+
+
+	tbl = fp->cltbl + 1;	/* Top of CLMT */
+	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
+	for (;;) {
+		ncl = *tbl++;			/* Number of cluters in the fragment */
+		if (!ncl) return 0;		/* End of table? (error) */
+		if (cl < ncl) break;	/* In this fragment? */
+		cl -= ncl; tbl++;		/* Next fragment */
+	}
+	return cl + *tbl;	/* Return the cluster number */
+}
+#endif	/* _USE_FASTSEEK */
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Directory handling - Set directory index                              */
+/*-----------------------------------------------------------------------*/
+
+static
+FRESULT dir_sdi (
+	DIR *dj,		/* Pointer to directory object */
+	WORD idx		/* Directory index number */
+)
+{
+	DWORD clst;
+	WORD ic;
+
+
+	dj->index = idx;
+	clst = dj->sclust;
+	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
+		return FR_INT_ERR;
+	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
+		clst = dj->fs->dirbase;
+
+	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
+		dj->clust = clst;
+		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
+			return FR_INT_ERR;
+		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
+	}
+	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
+		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
+		while (idx >= ic) {	/* Follow cluster chain */
+			clst = get_fat(dj->fs, clst);				/* Get next cluster */
+			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
+			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
+				return FR_INT_ERR;
+			idx -= ic;
+		}
+		dj->clust = clst;
+		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
+	}
+
+	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
+
+	return FR_OK;	/* Seek succeeded */
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Directory handling - Move directory index next                        */
+/*-----------------------------------------------------------------------*/
+
+static
+FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
+	DIR *dj,		/* Pointer to directory object */
+	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
+)
+{
+	DWORD clst;
+	WORD i;
+
+
+	stretch = stretch;		/* To suppress warning on read-only cfg. */
+	i = dj->index + 1;
+	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
+		return FR_NO_FILE;
+
+	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
+		dj->sect++;					/* Next sector */
+
+		if (dj->clust == 0) {	/* Static table */
+			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
+				return FR_NO_FILE;
+		}
+		else {					/* Dynamic table */
+			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
+				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
+				if (clst <= 1) return FR_INT_ERR;
+				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
+				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
+#if !_FS_READONLY
+					BYTE c;
+					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
+					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
+					if (clst == 0) return FR_DENIED;			/* No free cluster */
+					if (clst == 1) return FR_INT_ERR;
+					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
+					/* Clean-up stretched table */
+					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
+					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
+					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
+					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
+						dj->fs->wflag = 1;
+						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
+						dj->fs->winsect++;
+					}
+					dj->fs->winsect -= c;						/* Rewind window address */
+#else
+					return FR_NO_FILE;			/* Report EOT */
+#endif
+				}
+				dj->clust = clst;				/* Initialize data for new cluster */
+				dj->sect = clust2sect(dj->fs, clst);
+			}
+		}
+	}
+
+	dj->index = i;
+	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
+
+	return FR_OK;
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* LFN handling - Test/Pick/Fit an LFN segment from/to directory entry   */
+/*-----------------------------------------------------------------------*/
+#if _USE_LFN
+static
+const BYTE LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30};	/* Offset of LFN chars in the directory entry */
+
+
+static
+int cmp_lfn (			/* 1:Matched, 0:Not matched */
+	WCHAR *lfnbuf,		/* Pointer to the LFN to be compared */
+	BYTE *dir			/* Pointer to the directory entry containing a part of LFN */
+)
+{
+	UINT i, s;
+	WCHAR wc, uc;
+
+
+	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
+	s = 0; wc = 1;
+	do {
+		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
+		if (wc) {	/* Last char has not been processed */
+			wc = ff_wtoupper(uc);		/* Convert it to upper case */
+			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
+				return 0;				/* Not matched */
+		} else {
+			if (uc != 0xFFFF) return 0;	/* Check filler */
+		}
+	} while (++s < 13);				/* Repeat until all chars in the entry are checked */
+
+	if ((dir[LDIR_Ord] & LLE) && wc && lfnbuf[i])	/* Last segment matched but different length */
+		return 0;
+
+	return 1;						/* The part of LFN matched */
+}
+
+
+
+static
+int pick_lfn (			/* 1:Succeeded, 0:Buffer overflow */
+	WCHAR *lfnbuf,		/* Pointer to the Unicode-LFN buffer */
+	BYTE *dir			/* Pointer to the directory entry */
+)
+{
+	UINT i, s;
+	WCHAR wc, uc;
+
+
+	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
+
+	s = 0; wc = 1;
+	do {
+		uc = LD_WORD(dir+LfnOfs[s]);		/* Pick an LFN character from the entry */
+		if (wc) {	/* Last char has not been processed */
+			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
+			lfnbuf[i++] = wc = uc;			/* Store it */
+		} else {
+			if (uc != 0xFFFF) return 0;		/* Check filler */
+		}
+	} while (++s < 13);						/* Read all character in the entry */
+
+	if (dir[LDIR_Ord] & LLE) {				/* Put terminator if it is the last LFN part */
+		if (i >= _MAX_LFN) return 0;		/* Buffer overflow? */
+		lfnbuf[i] = 0;
+	}
+
+	return 1;
+}
+
+
+#if !_FS_READONLY
+static
+void fit_lfn (
+	const WCHAR *lfnbuf,	/* Pointer to the LFN buffer */
+	BYTE *dir,				/* Pointer to the directory entry */
+	BYTE ord,				/* LFN order (1-20) */
+	BYTE sum				/* SFN sum */
+)
+{
+	UINT i, s;
+	WCHAR wc;
+
+
+	dir[LDIR_Chksum] = sum;			/* Set check sum */
+	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
+	dir[LDIR_Type] = 0;
+	ST_WORD(dir+LDIR_FstClusLO, 0);
+
+	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
+	s = wc = 0;
+	do {
+		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
+		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
+		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
+	} while (++s < 13);
+	if (wc == 0xFFFF || !lfnbuf[i]) ord |= LLE;	/* Bottom LFN part is the start of LFN sequence */
+	dir[LDIR_Ord] = ord;			/* Set the LFN order */
+}
+
+#endif
+#endif
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Create numbered name                                                  */
+/*-----------------------------------------------------------------------*/
+#if _USE_LFN
+void gen_numname (
+	BYTE *dst,			/* Pointer to generated SFN */
+	const BYTE *src,	/* Pointer to source SFN to be modified */
+	const WCHAR *lfn,	/* Pointer to LFN */
+	WORD seq			/* Sequence number */
+)
+{
+	BYTE ns[8], c;
+	UINT i, j;
+
+
+	mem_cpy(dst, src, 11);
+
+	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
+		do seq = (seq >> 1) + (seq << 15) + (WORD)*lfn++; while (*lfn);
+	}
+
+	/* itoa (hexdecimal) */
+	i = 7;
+	do {
+		c = (seq % 16) + '0';
+		if (c > '9') c += 7;
+		ns[i--] = c;
+		seq /= 16;
+	} while (seq);
+	ns[i] = '~';
+
+	/* Append the number */
+	for (j = 0; j < i && dst[j] != ' '; j++) {
+		if (IsDBCS1(dst[j])) {
+			if (j == i - 1) break;
+			j++;
+		}
+	}
+	do {
+		dst[j++] = (i < 8) ? ns[i++] : ' ';
+	} while (j < 8);
+}
+#endif
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Calculate sum of an SFN                                               */
+/*-----------------------------------------------------------------------*/
+#if _USE_LFN
+static
+BYTE sum_sfn (
+	const BYTE *dir		/* Ptr to directory entry */
+)
+{
+	BYTE sum = 0;
+	UINT n = 11;
+
+	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
+	return sum;
+}
+#endif
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Directory handling - Find an object in the directory                  */
+/*-----------------------------------------------------------------------*/
+
+static
+FRESULT dir_find (
+	DIR *dj			/* Pointer to the directory object linked to the file name */
+)
+{
+	FRESULT res;
+	BYTE c, *dir;
+#if _USE_LFN
+	BYTE a, ord, sum;
+#endif
+
+	res = dir_sdi(dj, 0);			/* Rewind directory object */
+	if (res != FR_OK) return res;
+
+#if _USE_LFN
+	ord = sum = 0xFF;
+#endif
+	do {
+		res = move_window(dj->fs, dj->sect);
+		if (res != FR_OK) break;
+		dir = dj->dir;					/* Ptr to the directory entry of current index */
+		c = dir[DIR_Name];
+		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
+#if _USE_LFN	/* LFN configuration */
+		a = dir[DIR_Attr] & AM_MASK;
+		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
+			ord = 0xFF;
+		} else {
+			if (a == AM_LFN) {			/* An LFN entry is found */
+				if (dj->lfn) {
+					if (c & LLE) {		/* Is it start of LFN sequence? */
+						sum = dir[LDIR_Chksum];
+						c &= ~LLE; ord = c;	/* LFN start order */
+						dj->lfn_idx = dj->index;
+					}
+					/* Check validity of the LFN entry and compare it with given name */
+					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
+				}
+			} else {					/* An SFN entry is found */
+				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
+				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
+				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
+			}
+		}
+#else		/* Non LFN configuration */
+		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
+			break;
+#endif
+		res = dir_next(dj, 0);		/* Next entry */
+	} while (res == FR_OK);
+
+	return res;
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Read an object from the directory                                     */
+/*-----------------------------------------------------------------------*/
+#if _FS_MINIMIZE <= 1
+static
+FRESULT dir_read (
+	DIR *dj			/* Pointer to the directory object that pointing the entry to be read */
+)
+{
+	FRESULT res;
+	BYTE c, *dir;
+#if _USE_LFN
+	BYTE a, ord = 0xFF, sum = 0xFF;
+#endif
+
+	res = FR_NO_FILE;
+	while (dj->sect) {
+		res = move_window(dj->fs, dj->sect);
+		if (res != FR_OK) break;
+		dir = dj->dir;					/* Ptr to the directory entry of current index */
+		c = dir[DIR_Name];
+		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
+#if _USE_LFN	/* LFN configuration */
+		a = dir[DIR_Attr] & AM_MASK;
+		if (c == DDE || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
+			ord = 0xFF;
+		} else {
+			if (a == AM_LFN) {			/* An LFN entry is found */
+				if (c & LLE) {			/* Is it start of LFN sequence? */
+					sum = dir[LDIR_Chksum];
+					c &= ~LLE; ord = c;
+					dj->lfn_idx = dj->index;
+				}
+				/* Check LFN validity and capture it */
+				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
+			} else {					/* An SFN entry is found */
+				if (ord || sum != sum_sfn(dir))	/* Is there a valid LFN? */
+					dj->lfn_idx = 0xFFFF;		/* It has no LFN. */
+				break;
+			}
+		}
+#else		/* Non LFN configuration */
+		if (c != DDE && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL))	/* Is it a valid entry? */
+			break;
+#endif
+		res = dir_next(dj, 0);				/* Next entry */
+		if (res != FR_OK) break;
+	}
+
+	if (res != FR_OK) dj->sect = 0;
+
+	return res;
+}
+#endif
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Register an object to the directory                                   */
+/*-----------------------------------------------------------------------*/
+#if !_FS_READONLY
+static
+FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
+	DIR *dj				/* Target directory with object name to be created */
+)
+{
+	FRESULT res;
+	BYTE c, *dir;
+#if _USE_LFN	/* LFN configuration */
+	WORD n, ne, is;
+	BYTE sn[12], *fn, sum;
+	WCHAR *lfn;
+
+
+	fn = dj->fn; lfn = dj->lfn;
+	mem_cpy(sn, fn, 12);
+
+	if (_FS_RPATH && (sn[NS] & NS_DOT))		/* Cannot create dot entry */
+		return FR_INVALID_NAME;
+
+	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
+		fn[NS] = 0; dj->lfn = 0;			/* Find only SFN */
+		for (n = 1; n < 100; n++) {
+			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
+			res = dir_find(dj);				/* Check if the name collides with existing SFN */
+			if (res != FR_OK) break;
+		}
+		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
+		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
+		fn[NS] = sn[NS]; dj->lfn = lfn;
+	}
+
+	if (sn[NS] & NS_LFN) {			/* When LFN is to be created, reserve an SFN + LFN entries. */
+		for (ne = 0; lfn[ne]; ne++) ;
+		ne = (ne + 25) / 13;
+	} else {						/* Otherwise reserve only an SFN entry. */
+		ne = 1;
+	}
+
+	/* Reserve contiguous entries */
+	res = dir_sdi(dj, 0);
+	if (res != FR_OK) return res;
+	n = is = 0;
+	do {
+		res = move_window(dj->fs, dj->sect);
+		if (res != FR_OK) break;
+		c = *dj->dir;				/* Check the entry status */
+		if (c == DDE || c == 0) {	/* Is it a blank entry? */
+			if (n == 0) is = dj->index;	/* First index of the contiguous entry */
+			if (++n == ne) break;	/* A contiguous entry that required count is found */
+		} else {
+			n = 0;					/* Not a blank entry. Restart to search */
+		}
+		res = dir_next(dj, 1);		/* Next entry with table stretch */
+	} while (res == FR_OK);
+
+	if (res == FR_OK && ne > 1) {	/* Initialize LFN entry if needed */
+		res = dir_sdi(dj, is);
+		if (res == FR_OK) {
+			sum = sum_sfn(dj->fn);	/* Sum of the SFN tied to the LFN */
+			ne--;
+			do {					/* Store LFN entries in bottom first */
+				res = move_window(dj->fs, dj->sect);
+				if (res != FR_OK) break;
+				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
+				dj->fs->wflag = 1;
+				res = dir_next(dj, 0);	/* Next entry */
+			} while (res == FR_OK && --ne);
+		}
+	}
+
+#else	/* Non LFN configuration */
+	res = dir_sdi(dj, 0);
+	if (res == FR_OK) {
+		do {	/* Find a blank entry for the SFN */
+			res = move_window(dj->fs, dj->sect);
+			if (res != FR_OK) break;
+			c = *dj->dir;
+			if (c == DDE || c == 0) break;	/* Is it a blank entry? */
+			res = dir_next(dj, 1);			/* Next entry with table stretch */
+		} while (res == FR_OK);
+	}
+#endif
+
+	if (res == FR_OK) {		/* Initialize the SFN entry */
+		res = move_window(dj->fs, dj->sect);
+		if (res == FR_OK) {
+			dir = dj->dir;
+			mem_set(dir, 0, SZ_DIR);	/* Clean the entry */
+			mem_cpy(dir, dj->fn, 11);	/* Put SFN */
+#if _USE_LFN
+			dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT);	/* Put NT flag */
+#endif
+			dj->fs->wflag = 1;
+		}
+	}
+
+	return res;
+}
+#endif /* !_FS_READONLY */
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Remove an object from the directory                                   */
+/*-----------------------------------------------------------------------*/
+#if !_FS_READONLY && !_FS_MINIMIZE
+static
+FRESULT dir_remove (	/* FR_OK: Successful, FR_DISK_ERR: A disk error */
+	DIR *dj				/* Directory object pointing the entry to be removed */
+)
+{
+	FRESULT res;
+#if _USE_LFN	/* LFN configuration */
+	WORD i;
+
+	i = dj->index;	/* SFN index */
+	res = dir_sdi(dj, (WORD)((dj->lfn_idx == 0xFFFF) ? i : dj->lfn_idx));	/* Goto the SFN or top of the LFN entries */
+	if (res == FR_OK) {
+		do {
+			res = move_window(dj->fs, dj->sect);
+			if (res != FR_OK) break;
+			*dj->dir = DDE;			/* Mark the entry "deleted" */
+			dj->fs->wflag = 1;
+			if (dj->index >= i) break;	/* When reached SFN, all entries of the object has been deleted. */
+			res = dir_next(dj, 0);		/* Next entry */
+		} while (res == FR_OK);
+		if (res == FR_NO_FILE) res = FR_INT_ERR;
+	}
+
+#else			/* Non LFN configuration */
+	res = dir_sdi(dj, dj->index);
+	if (res == FR_OK) {
+		res = move_window(dj->fs, dj->sect);
+		if (res == FR_OK) {
+			*dj->dir = DDE;			/* Mark the entry "deleted" */
+			dj->fs->wflag = 1;
+		}
+	}
+#endif
+
+	return res;
+}
+#endif /* !_FS_READONLY */
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Pick a segment and create the object name in directory form           */
+/*-----------------------------------------------------------------------*/
+
+static
+FRESULT create_name (
+	DIR *dj,			/* Pointer to the directory object */
+	const TCHAR **path	/* Pointer to pointer to the segment in the path string */
+)
+{
+#ifdef _EXCVT
+	static const BYTE excvt[] = _EXCVT;	/* Upper conversion table for extended chars */
+#endif
+
+#if _USE_LFN	/* LFN configuration */
+	BYTE b, cf;
+	WCHAR w, *lfn;
+	UINT i, ni, si, di;
+	const TCHAR *p;
+
+	/* Create LFN in Unicode */
+	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
+	lfn = dj->lfn;
+	si = di = 0;
+	for (;;) {
+		w = p[si++];					/* Get a character */
+		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
+		if (di >= _MAX_LFN)				/* Reject too long name */
+			return FR_INVALID_NAME;
+#if !_LFN_UNICODE
+		w &= 0xFF;
+		if (IsDBCS1(w)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
+			b = (BYTE)p[si++];			/* Get 2nd byte */
+			if (!IsDBCS2(b))
+				return FR_INVALID_NAME;	/* Reject invalid sequence */
+			w = (w << 8) + b;			/* Create a DBC */
+		}
+		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
+		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
+#endif
+		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
+			return FR_INVALID_NAME;
+		lfn[di++] = w;					/* Store the Unicode char */
+	}
+	*path = &p[si];						/* Return pointer to the next segment */
+	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
+#if _FS_RPATH
+	if ((di == 1 && lfn[di-1] == '.') || /* Is this a dot entry? */
+		(di == 2 && lfn[di-1] == '.' && lfn[di-2] == '.')) {
+		lfn[di] = 0;
+		for (i = 0; i < 11; i++)
+			dj->fn[i] = (i < di) ? '.' : ' ';
+		dj->fn[i] = cf | NS_DOT;		/* This is a dot entry */
+		return FR_OK;
+	}
+#endif
+	while (di) {						/* Strip trailing spaces and dots */
+		w = lfn[di-1];
+		if (w != ' ' && w != '.') break;
+		di--;
+	}
+	if (!di) return FR_INVALID_NAME;	/* Reject nul string */
+
+	lfn[di] = 0;						/* LFN is created */
+
+	/* Create SFN in directory form */
+	mem_set(dj->fn, ' ', 11);
+	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
+	if (si) cf |= NS_LOSS | NS_LFN;
+	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
+
+	b = i = 0; ni = 8;
+	for (;;) {
+		w = lfn[si++];					/* Get an LFN char */
+		if (!w) break;					/* Break on end of the LFN */
+		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
+			cf |= NS_LOSS | NS_LFN; continue;
+		}
+
+		if (i >= ni || si == di) {		/* Extension or end of SFN */
+			if (ni == 11) {				/* Long extension */
+				cf |= NS_LOSS | NS_LFN; break;
+			}
+			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
+			if (si > di) break;			/* No extension */
+			si = di; i = 8; ni = 11;	/* Enter extension section */
+			b <<= 2; continue;
+		}
+
+		if (w >= 0x80) {				/* Non ASCII char */
+#ifdef _EXCVT
+			w = ff_convert(w, 0);		/* Unicode -> OEM code */
+			if (w) w = excvt[w - 0x80];	/* Convert extended char to upper (SBCS) */
+#else
+			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
+#endif
+			cf |= NS_LFN;				/* Force create LFN entry */
+		}
+
+		if (_DF1S && w >= 0x100) {		/* Double byte char (always false on SBCS cfg) */
+			if (i >= ni - 1) {
+				cf |= NS_LOSS | NS_LFN; i = ni; continue;
+			}
+			dj->fn[i++] = (BYTE)(w >> 8);
+		} else {						/* Single byte char */
+			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal chars for SFN */
+				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
+			} else {
+				if (IsUpper(w)) {		/* ASCII large capital */
+					b |= 2;
+				} else {
+					if (IsLower(w)) {	/* ASCII small capital */
+						b |= 1; w -= 0x20;
+					}
+				}
+			}
+		}
+		dj->fn[i++] = (BYTE)w;
+	}
+
+	if (dj->fn[0] == DDE) dj->fn[0] = NDDE;	/* If the first char collides with deleted mark, replace it with 0x05 */
+
+	if (ni == 8) b <<= 2;
+	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
+		cf |= NS_LFN;
+	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended char, NT flags are created */
+		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
+		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
+	}
+
+	dj->fn[NS] = cf;	/* SFN is created */
+
+	return FR_OK;
+
+
+#else	/* Non-LFN configuration */
+	BYTE b, c, d, *sfn;
+	UINT ni, si, i;
+	const char *p;
+
+	/* Create file name in directory form */
+	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
+	sfn = dj->fn;
+	mem_set(sfn, ' ', 11);
+	si = i = b = 0; ni = 8;
+#if _FS_RPATH
+	if (p[si] == '.') { /* Is this a dot entry? */
+		for (;;) {
+			c = (BYTE)p[si++];
+			if (c != '.' || si >= 3) break;
+			sfn[i++] = c;
+		}
+		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
+		*path = &p[si];									/* Return pointer to the next segment */
+		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
+		return FR_OK;
+	}
+#endif
+	for (;;) {
+		c = (BYTE)p[si++];
+		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
+		if (c == '.' || i >= ni) {
+			if (ni != 8 || c != '.') return FR_INVALID_NAME;
+			i = 8; ni = 11;
+			b <<= 2; continue;
+		}
+		if (c >= 0x80) {				/* Extended char? */
+			b |= 3;						/* Eliminate NT flag */
+#ifdef _EXCVT
+			c = excvt[c-0x80];			/* Upper conversion (SBCS) */
+#else
+#if !_DF1S	/* ASCII only cfg */
+			return FR_INVALID_NAME;
+#endif
+#endif
+		}
+		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
+			d = (BYTE)p[si++];			/* Get 2nd byte */
+			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
+				return FR_INVALID_NAME;
+			sfn[i++] = c;
+			sfn[i++] = d;
+		} else {						/* Single byte code */
+			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
+				return FR_INVALID_NAME;
+			if (IsUpper(c)) {			/* ASCII large capital? */
+				b |= 2;
+			} else {
+				if (IsLower(c)) {		/* ASCII small capital? */
+					b |= 1; c -= 0x20;
+				}
+			}
+			sfn[i++] = c;
+		}
+	}
+	*path = &p[si];						/* Return pointer to the next segment */
+	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
+
+	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
+	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first char collides with DDE, replace it with 0x05 */
+
+	if (ni == 8) b <<= 2;
+	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
+	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
+
+	sfn[NS] = c;		/* Store NT flag, File name is created */
+
+	return FR_OK;
+#endif
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Get file information from directory entry                             */
+/*-----------------------------------------------------------------------*/
+#if _FS_MINIMIZE <= 1
+static
+void get_fileinfo (		/* No return code */
+	DIR *dj,			/* Pointer to the directory object */
+	FILINFO *fno	 	/* Pointer to the file information to be filled */
+)
+{
+	UINT i;
+	BYTE nt, *dir;
+	TCHAR *p, c;
+
+
+	p = fno->fname;
+	if (dj->sect) {
+		dir = dj->dir;
+		nt = dir[DIR_NTres];		/* NT flag */
+		for (i = 0; i < 8; i++) {	/* Copy name body */
+			c = dir[i];
+			if (c == ' ') break;
+			if (c == NDDE) c = (TCHAR)DDE;
+			if (_USE_LFN && (nt & NS_BODY) && IsUpper(c)) c += 0x20;
+#if _LFN_UNICODE
+			if (IsDBCS1(c) && i < 7 && IsDBCS2(dir[i+1]))
+				c = (c << 8) | dir[++i];
+			c = ff_convert(c, 1);
+			if (!c) c = '?';
+#endif
+			*p++ = c;
+		}
+		if (dir[8] != ' ') {		/* Copy name extension */
+			*p++ = '.';
+			for (i = 8; i < 11; i++) {
+				c = dir[i];
+				if (c == ' ') break;
+				if (_USE_LFN && (nt & NS_EXT) && IsUpper(c)) c += 0x20;
+#if _LFN_UNICODE
+				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
+					c = (c << 8) | dir[++i];
+				c = ff_convert(c, 1);
+				if (!c) c = '?';
+#endif
+				*p++ = c;
+			}
+		}
+		fno->fattrib = dir[DIR_Attr];				/* Attribute */
+		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
+		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
+		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
+	}
+	*p = 0;		/* Terminate SFN str by a \0 */
+
+#if _USE_LFN
+	if (fno->lfname && fno->lfsize) {
+		TCHAR *tp = fno->lfname;
+		WCHAR w, *lfn;
+
+		i = 0;
+		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
+			lfn = dj->lfn;
+			while ((w = *lfn++) != 0) {			/* Get an LFN char */
+#if !_LFN_UNICODE
+				w = ff_convert(w, 0);			/* Unicode -> OEM conversion */
+				if (!w) { i = 0; break; }		/* Could not convert, no LFN */
+				if (_DF1S && w >= 0x100)		/* Put 1st byte if it is a DBC (always false on SBCS cfg) */
+					tp[i++] = (TCHAR)(w >> 8);
+#endif
+				if (i >= fno->lfsize - 1) { i = 0; break; }	/* Buffer overflow, no LFN */
+				tp[i++] = (TCHAR)w;
+			}
+		}
+		tp[i] = 0;	/* Terminate the LFN str by a \0 */
+	}
+#endif
+}
+#endif /* _FS_MINIMIZE <= 1 */
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Follow a file path                                                    */
+/*-----------------------------------------------------------------------*/
+
+static
+FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
+	DIR *dj,			/* Directory object to return last directory and found object */
+	const TCHAR *path	/* Full-path string to find a file or directory */
+)
+{
+	FRESULT res;
+	BYTE *dir, ns;
+
+
+#if _FS_RPATH
+	if (*path == '/' || *path == '\\') { /* There is a heading separator */
+		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
+	} else {							/* No heading separator */
+		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
+	}
+#else
+	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
+		path++;
+	dj->sclust = 0;						/* Start from the root dir */
+#endif
+
+	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
+		res = dir_sdi(dj, 0);
+		dj->dir = 0;
+
+	} else {							/* Follow path */
+		for (;;) {
+			res = create_name(dj, &path);	/* Get a segment */
+			if (res != FR_OK) break;
+			res = dir_find(dj);				/* Find it */
+			ns = *(dj->fn+NS);
+			if (res != FR_OK) {				/* Failed to find the object */
+				if (res != FR_NO_FILE) break;	/* Abort if any hard error occured */
+				/* Object not found */
+				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
+					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
+					res = FR_OK;
+					if (!(ns & NS_LAST)) continue;
+				} else {							/* Could not find the object */
+					if (!(ns & NS_LAST)) res = FR_NO_PATH;
+				}
+				break;
+			}
+			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
+			dir = dj->dir;						/* There is next segment. Follow the sub directory */
+			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
+				res = FR_NO_PATH; break;
+			}
+			dj->sclust = LD_CLUST(dir);
+		}
+	}
+
+	return res;
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Load a sector and check if it is an FAT Volume Boot Record            */
+/*-----------------------------------------------------------------------*/
+
+static
+BYTE check_fs (	/* 0:FAT-VBR, 1:Valid BR but not FAT, 2:Not a BR, 3:Disk error */
+	FATFS *fs,	/* File system object */
+	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
+)
+{
+	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
+		return 3;
+	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
+		return 2;
+
+	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
+		return 0;
+	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
+		return 0;
+
+	return 1;
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Check if the file system object is valid or not                       */
+/*-----------------------------------------------------------------------*/
+
+static
+FRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occurred */
+	const TCHAR **path,	/* Pointer to pointer to the path name (drive number) */
+	FATFS **rfs,		/* Pointer to pointer to the found file system object */
+	BYTE chk_wp			/* !=0: Check media write protection for write access */
+)
+{
+	BYTE fmt, b, pi, *tbl;
+	UINT vol;
+	DSTATUS stat;
+	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
+	WORD nrsv;
+	const TCHAR *p = *path;
+	FATFS *fs;
+
+	/* Get logical drive number from the path name */
+	vol = p[0] - '0';					/* Is there a drive number? */
+	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
+		p += 2; *path = p;				/* Return pointer to the path name */
+	} else {							/* No drive number is given */
+#if _FS_RPATH
+		vol = CurrVol;					/* Use current drive */
+#else
+		vol = 0;						/* Use drive 0 */
+#endif
+	}
+
+	/* Check if the file system object is valid or not */
+	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
+		return FR_INVALID_DRIVE;
+	*rfs = fs = FatFs[vol];				/* Return pointer to the corresponding file system object */
+	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
+
+	ENTER_FF(fs);						/* Lock file system */
+
+	if (fs->fs_type) {					/* If the logical drive has been mounted */
+		stat = disk_status(fs->drv);
+		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
+			if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))	/* Check write protection if needed */
+				return FR_WRITE_PROTECTED;
+			return FR_OK;				/* The file system object is valid */
+		}
+	}
+
+	/* The file system object is not valid. */
+	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */
+
+	fs->fs_type = 0;					/* Clear the file system object */
+	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
+	stat = disk_initialize(fs->drv);	/* Initialize low level disk I/O layer */
+	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
+		return FR_NOT_READY;			/* Failed to initialize due to no media or hard error */
+	if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))	/* Check disk write protection if needed */
+		return FR_WRITE_PROTECTED;
+#if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
+	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
+		return FR_DISK_ERR;
+#endif
+	/* Search FAT partition on the drive. Supports only generic partitionings, FDISK and SFD. */
+	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
+	if (LD2PT(vol) && !fmt) fmt = 1;	/* Force non-SFD if the volume is forced partition */
+	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
+		/* Check the partition listed in the partition table */
+		pi = LD2PT(vol);
+		if (pi) pi--;
+		tbl = &fs->win[MBR_Table + pi * SZ_PTE];/* Partition table */
+		if (tbl[4]) {						/* Is the partition existing? */
+			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
+			fmt = check_fs(fs, bsect);		/* Check the partition */
+		}
+	}
+	if (fmt == 3) return FR_DISK_ERR;
+	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
+
+	/* An FAT volume is found. Following code initializes the file system object */
+
+	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
+		return FR_NO_FILESYSTEM;
+
+	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
+	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
+	fs->fsize = fasize;
+
+	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
+	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
+	fasize *= b;										/* Number of sectors for FAT area */
+
+	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
+	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
+
+	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
+	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
+
+	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
+	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
+
+	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
+	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
+
+	/* Determine the FAT sub type */
+	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
+	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
+	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
+	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
+	fmt = FS_FAT12;
+	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
+	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
+
+	/* Boundaries and Limits */
+	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
+	fs->database = bsect + sysect;						/* Data start sector */
+	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
+	if (fmt == FS_FAT32) {
+		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
+		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
+		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
+	} else {
+		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
+		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
+		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
+			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
+	}
+	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
+		return FR_NO_FILESYSTEM;
+
+#if !_FS_READONLY
+	/* Initialize cluster allocation information */
+	fs->free_clust = 0xFFFFFFFF;
+	fs->last_clust = 0;
+
+	/* Get fsinfo if available */
+	if (fmt == FS_FAT32) {
+	 	fs->fsi_flag = 0;
+		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
+		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
+			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
+			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
+			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
+				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
+				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
+		}
+	}
+#endif
+	fs->fs_type = fmt;		/* FAT sub-type */
+	fs->id = ++Fsid;		/* File system mount ID */
+	fs->winsect = 0;		/* Invalidate sector cache */
+	fs->wflag = 0;
+#if _FS_RPATH
+	fs->cdir = 0;			/* Current directory (root dir) */
+#endif
+#if _FS_SHARE				/* Clear file lock semaphores */
+	clear_lock(fs);
+#endif
+
+	return FR_OK;
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Check if the file/dir object is valid or not                          */
+/*-----------------------------------------------------------------------*/
+
+static
+FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
+	FATFS *fs,		/* Pointer to the file system object */
+	WORD id			/* Member id of the target object to be checked */
+)
+{
+	if (!fs || !fs->fs_type || fs->id != id)
+		return FR_INVALID_OBJECT;
+
+	ENTER_FF(fs);		/* Lock file system */
+
+	if (disk_status(fs->drv) & STA_NOINIT)
+		return FR_NOT_READY;
+
+	return FR_OK;
+}
+
+
+
+
+/*--------------------------------------------------------------------------
+
+   Public Functions
+
+--------------------------------------------------------------------------*/
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Mount/Unmount a Logical Drive                                         */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_mount (
+	BYTE vol,		/* Logical drive number to be mounted/unmounted */
+	FATFS *fs		/* Pointer to new file system object (NULL for unmount)*/
+)
+{
+	FATFS *rfs;
+
+
+	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
+		return FR_INVALID_DRIVE;
+	rfs = FatFs[vol];			/* Get current fs object */
+
+	if (rfs) {
+#if _FS_SHARE
+		clear_lock(rfs);
+#endif
+#if _FS_REENTRANT				/* Discard sync object of the current volume */
+		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
+#endif
+		rfs->fs_type = 0;		/* Clear old fs object */
+	}
+
+	if (fs) {
+		fs->fs_type = 0;		/* Clear new fs object */
+#if _FS_REENTRANT				/* Create sync object for the new volume */
+		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
+#endif
+	}
+	FatFs[vol] = fs;			/* Register new fs object */
+
+	return FR_OK;
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Open or Create a File                                                 */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_open (
+	FIL *fp,			/* Pointer to the blank file object */
+	const TCHAR *path,	/* Pointer to the file name */
+	BYTE mode			/* Access mode and file open mode flags */
+)
+{
+	FRESULT res;
+	DIR dj;
+	BYTE *dir;
+	DEF_NAMEBUF;
+
+
+	fp->fs = 0;			/* Clear file object */
+
+#if !_FS_READONLY
+	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
+	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
+#else
+	mode &= FA_READ;
+	res = chk_mounted(&path, &dj.fs, 0);
+#endif
+	INIT_BUF(dj);
+	if (res == FR_OK)
+		res = follow_path(&dj, path);	/* Follow the file path */
+	dir = dj.dir;
+
+#if !_FS_READONLY	/* R/W configuration */
+	if (res == FR_OK) {
+		if (!dir)	/* Current dir itself */
+			res = FR_INVALID_NAME;
+#if _FS_SHARE
+		else
+			res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
+#endif
+	}
+	/* Create or Open a file */
+	if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
+		DWORD dw, cl;
+
+		if (res != FR_OK) {					/* No file, create new */
+			if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
+#if _FS_SHARE
+				res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
+#else
+				res = dir_register(&dj);
+#endif
+			mode |= FA_CREATE_ALWAYS;		/* File is created */
+			dir = dj.dir;					/* New entry */
+		}
+		else {								/* Any object is already existing */
+			if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
+				res = FR_DENIED;
+			} else {
+				if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
+					res = FR_EXIST;
+			}
+		}
+		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
+			dw = get_fattime();					/* Created time */
+			ST_DWORD(dir+DIR_CrtTime, dw);
+			dir[DIR_Attr] = 0;					/* Reset attribute */
+			ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
+			cl = LD_CLUST(dir);					/* Get start cluster */
+			ST_CLUST(dir, 0);					/* cluster = 0 */
+			dj.fs->wflag = 1;
+			if (cl) {							/* Remove the cluster chain if exist */
+				dw = dj.fs->winsect;
+				res = remove_chain(dj.fs, cl);
+				if (res == FR_OK) {
+					dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
+					res = move_window(dj.fs, dw);
+				}
+			}
+		}
+	}
+	else {	/* Open an existing file */
+		if (res == FR_OK) {						/* Follow succeeded */
+			if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
+				res = FR_NO_FILE;
+			} else {
+				if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
+					res = FR_DENIED;
+			}
+		}
+	}
+	if (res == FR_OK) {
+		if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
+			mode |= FA__WRITTEN;
+		fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
+		fp->dir_ptr = dir;
+#if _FS_SHARE
+		fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
+		if (!fp->lockid) res = FR_INT_ERR;
+#endif
+	}
+
+#else				/* R/O configuration */
+	if (res == FR_OK) {					/* Follow succeeded */
+		if (!dir) {						/* Current dir itself */
+			res = FR_INVALID_NAME;
+		} else {
+			if (dir[DIR_Attr] & AM_DIR)	/* It is a directory */
+				res = FR_NO_FILE;
+		}
+	}
+#endif
+	FREE_BUF();
+
+	if (res == FR_OK) {
+		fp->flag = mode;					/* File access mode */
+		fp->sclust = LD_CLUST(dir);			/* File start cluster */
+		fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
+		fp->fptr = 0;						/* File pointer */
+		fp->dsect = 0;
+#if _USE_FASTSEEK
+		fp->cltbl = 0;						/* Normal seek mode */
+#endif
+		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
+	}
+
+	LEAVE_FF(dj.fs, res);
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Read File                                                             */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_read (
+	FIL *fp, 		/* Pointer to the file object */
+	void *buff,		/* Pointer to data buffer */
+	UINT btr,		/* Number of bytes to read */
+	UINT *br		/* Pointer to number of bytes read */
+)
+{
+	FRESULT res;
+	DWORD clst, sect, remain;
+	UINT rcnt, cc;
+	BYTE csect, *rbuff = buff;
+
+
+	*br = 0;	/* Initialize byte counter */
+
+	res = validate(fp->fs, fp->id);				/* Check validity */
+	if (res != FR_OK) LEAVE_FF(fp->fs, res);
+	if (fp->flag & FA__ERROR)					/* Aborted file? */
+		LEAVE_FF(fp->fs, FR_INT_ERR);
+	if (!(fp->flag & FA_READ)) 					/* Check access mode */
+		LEAVE_FF(fp->fs, FR_DENIED);
+	remain = fp->fsize - fp->fptr;
+	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
+
+	for ( ;  btr;								/* Repeat until all data read */
+		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
+		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
+			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
+			if (!csect) {						/* On the cluster boundary? */
+				if (fp->fptr == 0) {			/* On the top of the file? */
+					clst = fp->sclust;			/* Follow from the origin */
+				} else {						/* Middle or end of the file */
+#if _USE_FASTSEEK
+					if (fp->cltbl)
+						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
+					else
+#endif
+						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
+				}
+				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
+				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
+				fp->clust = clst;				/* Update current cluster */
+			}
+			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
+			if (!sect) ABORT(fp->fs, FR_INT_ERR);
+			sect += csect;
+			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
+			if (cc) {							/* Read maximum contiguous sectors directly */
+				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
+					cc = fp->fs->csize - csect;
+				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
+					ABORT(fp->fs, FR_DISK_ERR);
+#if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
+#if _FS_TINY
+				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
+					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
+#else
+				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
+					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
+#endif
+#endif
+				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
+				continue;
+			}
+#if !_FS_TINY
+			if (fp->dsect != sect) {			/* Load data sector if not in cache */
+#if !_FS_READONLY
+				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
+					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
+						ABORT(fp->fs, FR_DISK_ERR);
+					fp->flag &= ~FA__DIRTY;
+				}
+#endif
+				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
+					ABORT(fp->fs, FR_DISK_ERR);
+			}
+#endif
+			fp->dsect = sect;
+		}
+		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
+		if (rcnt > btr) rcnt = btr;
+#if _FS_TINY
+		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
+			ABORT(fp->fs, FR_DISK_ERR);
+		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
+#else
+		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
+#endif
+	}
+
+	LEAVE_FF(fp->fs, FR_OK);
+}
+
+
+
+
+#if !_FS_READONLY
+/*-----------------------------------------------------------------------*/
+/* Write File                                                            */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_write (
+	FIL *fp,			/* Pointer to the file object */
+	const void *buff,	/* Pointer to the data to be written */
+	UINT btw,			/* Number of bytes to write */
+	UINT *bw			/* Pointer to number of bytes written */
+)
+{
+	FRESULT res;
+	DWORD clst, sect;
+	UINT wcnt, cc;
+	const BYTE *wbuff = buff;
+	BYTE csect;
+
+
+	*bw = 0;	/* Initialize byte counter */
+
+	res = validate(fp->fs, fp->id);			/* Check validity */
+	if (res != FR_OK) LEAVE_FF(fp->fs, res);
+	if (fp->flag & FA__ERROR)				/* Aborted file? */
+		LEAVE_FF(fp->fs, FR_INT_ERR);
+	if (!(fp->flag & FA_WRITE))				/* Check access mode */
+		LEAVE_FF(fp->fs, FR_DENIED);
+	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */
+
+	for ( ;  btw;							/* Repeat until all data written */
+		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
+		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
+			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
+			if (!csect) {					/* On the cluster boundary? */
+				if (fp->fptr == 0) {		/* On the top of the file? */
+					clst = fp->sclust;		/* Follow from the origin */
+					if (clst == 0)			/* When no cluster is allocated, */
+						fp->sclust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
+				} else {					/* Middle or end of the file */
+#if _USE_FASTSEEK
+					if (fp->cltbl)
+						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
+					else
+#endif
+						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
+				}
+				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
+				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
+				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
+				fp->clust = clst;			/* Update current cluster */
+			}
+#if _FS_TINY
+			if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0))	/* Write-back sector cache */
+				ABORT(fp->fs, FR_DISK_ERR);
+#else
+			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
+				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
+					ABORT(fp->fs, FR_DISK_ERR);
+				fp->flag &= ~FA__DIRTY;
+			}
+#endif
+			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
+			if (!sect) ABORT(fp->fs, FR_INT_ERR);
+			sect += csect;
+			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
+			if (cc) {						/* Write maximum contiguous sectors directly */
+				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
+					cc = fp->fs->csize - csect;
+				if (disk_write(fp->fs->drv, wbuff, sect, (BYTE)cc) != RES_OK)
+					ABORT(fp->fs, FR_DISK_ERR);
+#if _FS_TINY
+				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
+					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
+					fp->fs->wflag = 0;
+				}
+#else
+				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
+					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
+					fp->flag &= ~FA__DIRTY;
+				}
+#endif
+				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
+				continue;
+			}
+#if _FS_TINY
+			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
+				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
+				fp->fs->winsect = sect;
+			}
+#else
+			if (fp->dsect != sect) {		/* Fill sector cache with file data */
+				if (fp->fptr < fp->fsize &&
+					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
+						ABORT(fp->fs, FR_DISK_ERR);
+			}
+#endif
+			fp->dsect = sect;
+		}
+		wcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
+		if (wcnt > btw) wcnt = btw;
+#if _FS_TINY
+		if (move_window(fp->fs, fp->dsect))	/* Move sector window */
+			ABORT(fp->fs, FR_DISK_ERR);
+		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
+		fp->fs->wflag = 1;
+#else
+		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
+		fp->flag |= FA__DIRTY;
+#endif
+	}
+
+	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
+	fp->flag |= FA__WRITTEN;						/* Set file change flag */
+
+	LEAVE_FF(fp->fs, FR_OK);
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Synchronize the File Object                                           */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_sync (
+	FIL *fp		/* Pointer to the file object */
+)
+{
+	FRESULT res;
+	DWORD tim;
+	BYTE *dir;
+
+
+	res = validate(fp->fs, fp->id);		/* Check validity of the object */
+	if (res == FR_OK) {
+		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
+#if !_FS_TINY	/* Write-back dirty buffer */
+			if (fp->flag & FA__DIRTY) {
+				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
+					LEAVE_FF(fp->fs, FR_DISK_ERR);
+				fp->flag &= ~FA__DIRTY;
+			}
+#endif
+			/* Update the directory entry */
+			res = move_window(fp->fs, fp->dir_sect);
+			if (res == FR_OK) {
+				dir = fp->dir_ptr;
+				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
+				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
+				ST_CLUST(dir, fp->sclust);					/* Update start cluster */
+				tim = get_fattime();						/* Update updated time */
+				ST_DWORD(dir+DIR_WrtTime, tim);
+				fp->flag &= ~FA__WRITTEN;
+				fp->fs->wflag = 1;
+				res = sync(fp->fs);
+			}
+		}
+	}
+
+	LEAVE_FF(fp->fs, res);
+}
+
+#endif /* !_FS_READONLY */
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Close File                                                            */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_close (
+	FIL *fp		/* Pointer to the file object to be closed */
+)
+{
+	FRESULT res;
+
+#if _FS_READONLY
+	FATFS *fs = fp->fs;
+	res = validate(fs, fp->id);
+	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
+	LEAVE_FF(fs, res);
+
+#else
+	res = f_sync(fp);		/* Flush cached data */
+#if _FS_SHARE
+	if (res == FR_OK) {		/* Decrement open counter */
+#if _FS_REENTRANT
+		res = validate(fp->fs, fp->id);
+		if (res == FR_OK) {
+			res = dec_lock(fp->lockid);	
+			unlock_fs(fp->fs, FR_OK);
+		}
+#else
+		res = dec_lock(fp->lockid);
+#endif
+	}
+#endif
+	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
+	return res;
+#endif
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Current Drive/Directory Handlings                                     */
+/*-----------------------------------------------------------------------*/
+
+#if _FS_RPATH >= 1
+
+FRESULT f_chdrive (
+	BYTE drv		/* Drive number */
+)
+{
+	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
+
+	CurrVol = drv;
+
+	return FR_OK;
+}
+
+
+
+FRESULT f_chdir (
+	const TCHAR *path	/* Pointer to the directory path */
+)
+{
+	FRESULT res;
+	DIR dj;
+	DEF_NAMEBUF;
+
+
+	res = chk_mounted(&path, &dj.fs, 0);
+	if (res == FR_OK) {
+		INIT_BUF(dj);
+		res = follow_path(&dj, path);		/* Follow the path */
+		FREE_BUF();
+		if (res == FR_OK) {					/* Follow completed */
+			if (!dj.dir) {
+				dj.fs->cdir = dj.sclust;	/* Start directory itself */
+			} else {
+				if (dj.dir[DIR_Attr] & AM_DIR)	/* Reached to the directory */
+					dj.fs->cdir = LD_CLUST(dj.dir);
+				else
+					res = FR_NO_PATH;		/* Reached but a file */
+			}
+		}
+		if (res == FR_NO_FILE) res = FR_NO_PATH;
+	}
+
+	LEAVE_FF(dj.fs, res);
+}
+
+
+#if _FS_RPATH >= 2
+FRESULT f_getcwd (
+	TCHAR *path,	/* Pointer to the directory path */
+	UINT sz_path	/* Size of path */
+)
+{
+	FRESULT res;
+	DIR dj;
+	UINT i, n;
+	DWORD ccl;
+	TCHAR *tp;
+	FILINFO fno;
+	DEF_NAMEBUF;
+
+
+	*path = 0;
+	res = chk_mounted((const TCHAR**)&path, &dj.fs, 0);	/* Get current volume */
+	if (res == FR_OK) {
+		INIT_BUF(dj);
+		i = sz_path;		/* Bottom of buffer (dir stack base) */
+		dj.sclust = dj.fs->cdir;			/* Start to follow upper dir from current dir */
+		while ((ccl = dj.sclust) != 0) {	/* Repeat while current dir is a sub-dir */
+			res = dir_sdi(&dj, 1);			/* Get parent dir */
+			if (res != FR_OK) break;
+			res = dir_read(&dj);
+			if (res != FR_OK) break;
+			dj.sclust = LD_CLUST(dj.dir);	/* Goto parent dir */
+			res = dir_sdi(&dj, 0);
+			if (res != FR_OK) break;
+			do {							/* Find the entry links to the child dir */
+				res = dir_read(&dj);
+				if (res != FR_OK) break;
+				if (ccl == LD_CLUST(dj.dir)) break;	/* Found the entry */
+				res = dir_next(&dj, 0);	
+			} while (res == FR_OK);
+			if (res == FR_NO_FILE) res = FR_INT_ERR;/* It cannot be 'not found'. */
+			if (res != FR_OK) break;
+#if _USE_LFN
+			fno.lfname = path;
+			fno.lfsize = i;
+#endif
+			get_fileinfo(&dj, &fno);		/* Get the dir name and push it to the buffer */
+			tp = fno.fname;
+			if (_USE_LFN && *path) tp = path;
+			for (n = 0; tp[n]; n++) ;
+			if (i < n + 3) {
+				res = FR_NOT_ENOUGH_CORE; break;
+			}
+			while (n) path[--i] = tp[--n];
+			path[--i] = '/';
+		}
+		tp = path;
+		if (res == FR_OK) {
+			*tp++ = '0' + CurrVol;			/* Put drive number */
+			*tp++ = ':';
+			if (i == sz_path) {				/* Root-dir */
+				*tp++ = '/';
+			} else {						/* Sub-dir */
+				do		/* Add stacked path str */
+					*tp++ = path[i++];
+				while (i < sz_path);
+			}
+		}
+		*tp = 0;
+		FREE_BUF();
+	}
+
+	LEAVE_FF(dj.fs, res);
+}
+#endif /* _FS_RPATH >= 2 */
+#endif /* _FS_RPATH >= 1 */
+
+
+
+#if _FS_MINIMIZE <= 2
+/*-----------------------------------------------------------------------*/
+/* Seek File R/W Pointer                                                 */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_lseek (
+	FIL *fp,		/* Pointer to the file object */
+	DWORD ofs		/* File pointer from top of file */
+)
+{
+	FRESULT res;
+
+
+	res = validate(fp->fs, fp->id);		/* Check validity of the object */
+	if (res != FR_OK) LEAVE_FF(fp->fs, res);
+	if (fp->flag & FA__ERROR)			/* Check abort flag */
+		LEAVE_FF(fp->fs, FR_INT_ERR);
+
+#if _USE_FASTSEEK
+	if (fp->cltbl) {	/* Fast seek */
+		DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
+
+		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
+			tbl = fp->cltbl;
+			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
+			cl = fp->sclust;			/* Top of the chain */
+			if (cl) {
+				do {
+					/* Get a fragment */
+					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
+					do {
+						pcl = cl; ncl++;
+						cl = get_fat(fp->fs, cl);
+						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
+						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
+					} while (cl == pcl + 1);
+					if (ulen <= tlen) {		/* Store the length and top of the fragment */
+						*tbl++ = ncl; *tbl++ = tcl;
+					}
+				} while (cl < fp->fs->n_fatent);	/* Repeat until end of chain */
+			}
+			*fp->cltbl = ulen;	/* Number of items used */
+			if (ulen <= tlen)
+				*tbl = 0;		/* Terminate table */
+			else
+				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
+
+		} else {						/* Fast seek */
+			if (ofs > fp->fsize)		/* Clip offset at the file size */
+				ofs = fp->fsize;
+			fp->fptr = ofs;				/* Set file pointer */
+			if (ofs) {
+				fp->clust = clmt_clust(fp, ofs - 1);
+				dsc = clust2sect(fp->fs, fp->clust);
+				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
+				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
+				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
+#if !_FS_TINY
+#if !_FS_READONLY
+					if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
+						if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
+							ABORT(fp->fs, FR_DISK_ERR);
+						fp->flag &= ~FA__DIRTY;
+					}
+#endif
+					if (disk_read(fp->fs->drv, fp->buf, dsc, 1) != RES_OK)	/* Load current sector */
+						ABORT(fp->fs, FR_DISK_ERR);
+#endif
+					fp->dsect = dsc;
+				}
+			}
+		}
+	} else
+#endif
+
+	/* Normal Seek */
+	{
+		DWORD clst, bcs, nsect, ifptr;
+
+		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
+#if !_FS_READONLY
+			 && !(fp->flag & FA_WRITE)
+#endif
+			) ofs = fp->fsize;
+
+		ifptr = fp->fptr;
+		fp->fptr = nsect = 0;
+		if (ofs) {
+			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
+			if (ifptr > 0 &&
+				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
+				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
+				ofs -= fp->fptr;
+				clst = fp->clust;
+			} else {									/* When seek to back cluster, */
+				clst = fp->sclust;						/* start from the first cluster */
+#if !_FS_READONLY
+				if (clst == 0) {						/* If no cluster chain, create a new chain */
+					clst = create_chain(fp->fs, 0);
+					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
+					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
+					fp->sclust = clst;
+				}
+#endif
+				fp->clust = clst;
+			}
+			if (clst != 0) {
+				while (ofs > bcs) {						/* Cluster following loop */
+#if !_FS_READONLY
+					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
+						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
+						if (clst == 0) {				/* When disk gets full, clip file size */
+							ofs = bcs; break;
+						}
+					} else
+#endif
+						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
+					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
+					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
+					fp->clust = clst;
+					fp->fptr += bcs;
+					ofs -= bcs;
+				}
+				fp->fptr += ofs;
+				if (ofs % SS(fp->fs)) {
+					nsect = clust2sect(fp->fs, clst);	/* Current sector */
+					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
+					nsect += ofs / SS(fp->fs);
+				}
+			}
+		}
+		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
+#if !_FS_TINY
+#if !_FS_READONLY
+			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
+				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
+					ABORT(fp->fs, FR_DISK_ERR);
+				fp->flag &= ~FA__DIRTY;
+			}
+#endif
+			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
+				ABORT(fp->fs, FR_DISK_ERR);
+#endif
+			fp->dsect = nsect;
+		}
+#if !_FS_READONLY
+		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
+			fp->fsize = fp->fptr;
+			fp->flag |= FA__WRITTEN;
+		}
+#endif
+	}
+
+	LEAVE_FF(fp->fs, res);
+}
+
+
+
+#if _FS_MINIMIZE <= 1
+/*-----------------------------------------------------------------------*/
+/* Create a Directroy Object                                             */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_opendir (
+	DIR *dj,			/* Pointer to directory object to create */
+	const TCHAR *path	/* Pointer to the directory path */
+)
+{
+	FRESULT res;
+	DEF_NAMEBUF;
+
+
+	res = chk_mounted(&path, &dj->fs, 0);
+	if (res == FR_OK) {
+		INIT_BUF(*dj);
+		res = follow_path(dj, path);			/* Follow the path to the directory */
+		FREE_BUF();
+		if (res == FR_OK) {						/* Follow completed */
+			if (dj->dir) {						/* It is not the root dir */
+				if (dj->dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
+					dj->sclust = LD_CLUST(dj->dir);
+				} else {						/* The object is not a directory */
+					res = FR_NO_PATH;
+				}
+			}
+			if (res == FR_OK) {
+				dj->id = dj->fs->id;
+				res = dir_sdi(dj, 0);			/* Rewind dir */
+			}
+		}
+		if (res == FR_NO_FILE) res = FR_NO_PATH;
+	}
+
+	LEAVE_FF(dj->fs, res);
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Read Directory Entry in Sequense                                      */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_readdir (
+	DIR *dj,			/* Pointer to the open directory object */
+	FILINFO *fno		/* Pointer to file information to return */
+)
+{
+	FRESULT res;
+	DEF_NAMEBUF;
+
+
+	res = validate(dj->fs, dj->id);			/* Check validity of the object */
+	if (res == FR_OK) {
+		if (!fno) {
+			res = dir_sdi(dj, 0);			/* Rewind the directory object */
+		} else {
+			INIT_BUF(*dj);
+			res = dir_read(dj);				/* Read an directory item */
+			if (res == FR_NO_FILE) {		/* Reached end of dir */
+				dj->sect = 0;
+				res = FR_OK;
+			}
+			if (res == FR_OK) {				/* A valid entry is found */
+				get_fileinfo(dj, fno);		/* Get the object information */
+				res = dir_next(dj, 0);		/* Increment index for next */
+				if (res == FR_NO_FILE) {
+					dj->sect = 0;
+					res = FR_OK;
+				}
+			}
+			FREE_BUF();
+		}
+	}
+
+	LEAVE_FF(dj->fs, res);
+}
+
+
+
+#if _FS_MINIMIZE == 0
+/*-----------------------------------------------------------------------*/
+/* Get File Status                                                       */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_stat (
+	const TCHAR *path,	/* Pointer to the file path */
+	FILINFO *fno		/* Pointer to file information to return */
+)
+{
+	FRESULT res;
+	DIR dj;
+	DEF_NAMEBUF;
+
+
+	res = chk_mounted(&path, &dj.fs, 0);
+	if (res == FR_OK) {
+		INIT_BUF(dj);
+		res = follow_path(&dj, path);	/* Follow the file path */
+		if (res == FR_OK) {				/* Follow completed */
+			if (dj.dir)		/* Found an object */
+				get_fileinfo(&dj, fno);
+			else			/* It is root dir */
+				res = FR_INVALID_NAME;
+		}
+		FREE_BUF();
+	}
+
+	LEAVE_FF(dj.fs, res);
+}
+
+
+
+#if !_FS_READONLY
+/*-----------------------------------------------------------------------*/
+/* Get Number of Free Clusters                                           */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_getfree (
+	const TCHAR *path,	/* Pointer to the logical drive number (root dir) */
+	DWORD *nclst,		/* Pointer to the variable to return number of free clusters */
+	FATFS **fatfs		/* Pointer to pointer to corresponding file system object to return */
+)
+{
+	FRESULT res;
+	DWORD n, clst, sect, stat;
+	UINT i;
+	BYTE fat, *p;
+
+
+	/* Get drive number */
+	res = chk_mounted(&path, fatfs, 0);
+	if (res == FR_OK) {
+		/* If free_clust is valid, return it without full cluster scan */
+		if ((*fatfs)->free_clust <= (*fatfs)->n_fatent - 2) {
+			*nclst = (*fatfs)->free_clust;
+		} else {
+			/* Get number of free clusters */
+			fat = (*fatfs)->fs_type;
+			n = 0;
+			if (fat == FS_FAT12) {
+				clst = 2;
+				do {
+					stat = get_fat(*fatfs, clst);
+					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
+					if (stat == 1) { res = FR_INT_ERR; break; }
+					if (stat == 0) n++;
+				} while (++clst < (*fatfs)->n_fatent);
+			} else {
+				clst = (*fatfs)->n_fatent;
+				sect = (*fatfs)->fatbase;
+				i = 0; p = 0;
+				do {
+					if (!i) {
+						res = move_window(*fatfs, sect++);
+						if (res != FR_OK) break;
+						p = (*fatfs)->win;
+						i = SS(*fatfs);
+					}
+					if (fat == FS_FAT16) {
+						if (LD_WORD(p) == 0) n++;
+						p += 2; i -= 2;
+					} else {
+						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
+						p += 4; i -= 4;
+					}
+				} while (--clst);
+			}
+			(*fatfs)->free_clust = n;
+			if (fat == FS_FAT32) (*fatfs)->fsi_flag = 1;
+			*nclst = n;
+		}
+	}
+	LEAVE_FF(*fatfs, res);
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Truncate File                                                         */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_truncate (
+	FIL *fp		/* Pointer to the file object */
+)
+{
+	FRESULT res;
+	DWORD ncl;
+
+
+	res = validate(fp->fs, fp->id);		/* Check validity of the object */
+	if (res == FR_OK) {
+		if (fp->flag & FA__ERROR) {			/* Check abort flag */
+			res = FR_INT_ERR;
+		} else {
+			if (!(fp->flag & FA_WRITE))		/* Check access mode */
+				res = FR_DENIED;
+		}
+	}
+	if (res == FR_OK) {
+		if (fp->fsize > fp->fptr) {
+			fp->fsize = fp->fptr;	/* Set file size to current R/W point */
+			fp->flag |= FA__WRITTEN;
+			if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
+				res = remove_chain(fp->fs, fp->sclust);
+				fp->sclust = 0;
+			} else {				/* When truncate a part of the file, remove remaining clusters */
+				ncl = get_fat(fp->fs, fp->clust);
+				res = FR_OK;
+				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
+				if (ncl == 1) res = FR_INT_ERR;
+				if (res == FR_OK && ncl < fp->fs->n_fatent) {
+					res = put_fat(fp->fs, fp->clust, 0x0FFFFFFF);
+					if (res == FR_OK) res = remove_chain(fp->fs, ncl);
+				}
+			}
+		}
+		if (res != FR_OK) fp->flag |= FA__ERROR;
+	}
+
+	LEAVE_FF(fp->fs, res);
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Delete a File or Directory                                            */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_unlink (
+	const TCHAR *path		/* Pointer to the file or directory path */
+)
+{
+	FRESULT res;
+	DIR dj, sdj;
+	BYTE *dir;
+	DWORD dclst;
+	DEF_NAMEBUF;
+
+
+	res = chk_mounted(&path, &dj.fs, 1);
+	if (res == FR_OK) {
+		INIT_BUF(dj);
+		res = follow_path(&dj, path);		/* Follow the file path */
+		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
+			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
+#if _FS_SHARE
+		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Cannot remove open file */
+#endif
+		if (res == FR_OK) {					/* The object is accessible */
+			dir = dj.dir;
+			if (!dir) {
+				res = FR_INVALID_NAME;		/* Cannot remove the start directory */
+			} else {
+				if (dir[DIR_Attr] & AM_RDO)
+					res = FR_DENIED;		/* Cannot remove R/O object */
+			}
+			dclst = LD_CLUST(dir);
+			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-dir? */
+				if (dclst < 2) {
+					res = FR_INT_ERR;
+				} else {
+					mem_cpy(&sdj, &dj, sizeof(DIR));	/* Check if the sub-dir is empty or not */
+					sdj.sclust = dclst;
+					res = dir_sdi(&sdj, 2);		/* Exclude dot entries */
+					if (res == FR_OK) {
+						res = dir_read(&sdj);
+						if (res == FR_OK			/* Not empty dir */
+#if _FS_RPATH
+						|| dclst == sdj.fs->cdir	/* Current dir */
+#endif
+						) res = FR_DENIED;
+						if (res == FR_NO_FILE) res = FR_OK;	/* Empty */
+					}
+				}
+			}
+			if (res == FR_OK) {
+				res = dir_remove(&dj);		/* Remove the directory entry */
+				if (res == FR_OK) {
+					if (dclst)				/* Remove the cluster chain if exist */
+						res = remove_chain(dj.fs, dclst);
+					if (res == FR_OK) res = sync(dj.fs);
+				}
+			}
+		}
+		FREE_BUF();
+	}
+	LEAVE_FF(dj.fs, res);
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Create a Directory                                                    */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_mkdir (
+	const TCHAR *path		/* Pointer to the directory path */
+)
+{
+	FRESULT res;
+	DIR dj;
+	BYTE *dir, n;
+	DWORD dsc, dcl, pcl, tim = get_fattime();
+	DEF_NAMEBUF;
+
+
+	res = chk_mounted(&path, &dj.fs, 1);
+	if (res == FR_OK) {
+		INIT_BUF(dj);
+		res = follow_path(&dj, path);			/* Follow the file path */
+		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
+		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
+			res = FR_INVALID_NAME;
+		if (res == FR_NO_FILE) {				/* Can create a new directory */
+			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
+			res = FR_OK;
+			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
+			if (dcl == 1) res = FR_INT_ERR;
+			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
+			if (res == FR_OK)					/* Flush FAT */
+				res = move_window(dj.fs, 0);
+			if (res == FR_OK) {					/* Initialize the new directory table */
+				dsc = clust2sect(dj.fs, dcl);
+				dir = dj.fs->win;
+				mem_set(dir, 0, SS(dj.fs));
+				mem_set(dir+DIR_Name, ' ', 8+3);	/* Create "." entry */
+				dir[DIR_Name] = '.';
+				dir[DIR_Attr] = AM_DIR;
+				ST_DWORD(dir+DIR_WrtTime, tim);
+				ST_CLUST(dir, dcl);
+				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
+				dir[33] = '.'; pcl = dj.sclust;
+				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
+					pcl = 0;
+				ST_CLUST(dir+SZ_DIR, pcl);
+				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
+					dj.fs->winsect = dsc++;
+					dj.fs->wflag = 1;
+					res = move_window(dj.fs, 0);
+					if (res != FR_OK) break;
+					mem_set(dir, 0, SS(dj.fs));
+				}
+			}
+			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
+			if (res != FR_OK) {
+				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
+			} else {
+				dir = dj.dir;
+				dir[DIR_Attr] = AM_DIR;				/* Attribute */
+				ST_DWORD(dir+DIR_WrtTime, tim);		/* Created time */
+				ST_CLUST(dir, dcl);					/* Table start cluster */
+				dj.fs->wflag = 1;
+				res = sync(dj.fs);
+			}
+		}
+		FREE_BUF();
+	}
+
+	LEAVE_FF(dj.fs, res);
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Change Attribute                                                      */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_chmod (
+	const TCHAR *path,	/* Pointer to the file path */
+	BYTE value,			/* Attribute bits */
+	BYTE mask			/* Attribute mask to change */
+)
+{
+	FRESULT res;
+	DIR dj;
+	BYTE *dir;
+	DEF_NAMEBUF;
+
+
+	res = chk_mounted(&path, &dj.fs, 1);
+	if (res == FR_OK) {
+		INIT_BUF(dj);
+		res = follow_path(&dj, path);		/* Follow the file path */
+		FREE_BUF();
+		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
+			res = FR_INVALID_NAME;
+		if (res == FR_OK) {
+			dir = dj.dir;
+			if (!dir) {						/* Is it a root directory? */
+				res = FR_INVALID_NAME;
+			} else {						/* File or sub directory */
+				mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
+				dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
+				dj.fs->wflag = 1;
+				res = sync(dj.fs);
+			}
+		}
+	}
+
+	LEAVE_FF(dj.fs, res);
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Change Timestamp                                                      */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_utime (
+	const TCHAR *path,	/* Pointer to the file/directory name */
+	const FILINFO *fno	/* Pointer to the time stamp to be set */
+)
+{
+	FRESULT res;
+	DIR dj;
+	BYTE *dir;
+	DEF_NAMEBUF;
+
+
+	res = chk_mounted(&path, &dj.fs, 1);
+	if (res == FR_OK) {
+		INIT_BUF(dj);
+		res = follow_path(&dj, path);	/* Follow the file path */
+		FREE_BUF();
+		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
+			res = FR_INVALID_NAME;
+		if (res == FR_OK) {
+			dir = dj.dir;
+			if (!dir) {					/* Root directory */
+				res = FR_INVALID_NAME;
+			} else {					/* File or sub-directory */
+				ST_WORD(dir+DIR_WrtTime, fno->ftime);
+				ST_WORD(dir+DIR_WrtDate, fno->fdate);
+				dj.fs->wflag = 1;
+				res = sync(dj.fs);
+			}
+		}
+	}
+
+	LEAVE_FF(dj.fs, res);
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Rename File/Directory                                                 */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_rename (
+	const TCHAR *path_old,	/* Pointer to the old name */
+	const TCHAR *path_new	/* Pointer to the new name */
+)
+{
+	FRESULT res;
+	DIR djo, djn;
+	BYTE buf[21], *dir;
+	DWORD dw;
+	DEF_NAMEBUF;
+
+
+	res = chk_mounted(&path_old, &djo.fs, 1);
+	if (res == FR_OK) {
+		djn.fs = djo.fs;
+		INIT_BUF(djo);
+		res = follow_path(&djo, path_old);		/* Check old object */
+		if (_FS_RPATH && res == FR_OK && (djo.fn[NS] & NS_DOT))
+			res = FR_INVALID_NAME;
+#if _FS_SHARE
+		if (res == FR_OK) res = chk_lock(&djo, 2);
+#endif
+		if (res == FR_OK) {						/* Old object is found */
+			if (!djo.dir) {						/* Is root dir? */
+				res = FR_NO_FILE;
+			} else {
+				mem_cpy(buf, djo.dir+DIR_Attr, 21);		/* Save the object information except for name */
+				mem_cpy(&djn, &djo, sizeof(DIR));		/* Check new object */
+				res = follow_path(&djn, path_new);
+				if (res == FR_OK) res = FR_EXIST;		/* The new object name is already existing */
+				if (res == FR_NO_FILE) { 				/* Is it a valid path and no name collision? */
+/* Start critical section that any interruption or error can cause cross-link */
+					res = dir_register(&djn);			/* Register the new entry */
+					if (res == FR_OK) {
+						dir = djn.dir;					/* Copy object information except for name */
+						mem_cpy(dir+13, buf+2, 19);
+						dir[DIR_Attr] = buf[0] | AM_ARC;
+						djo.fs->wflag = 1;
+						if (djo.sclust != djn.sclust && (dir[DIR_Attr] & AM_DIR)) {		/* Update .. entry in the directory if needed */
+							dw = clust2sect(djn.fs, LD_CLUST(dir));
+							if (!dw) {
+								res = FR_INT_ERR;
+							} else {
+								res = move_window(djn.fs, dw);
+								dir = djn.fs->win+SZ_DIR;	/* .. entry */
+								if (res == FR_OK && dir[1] == '.') {
+									dw = (djn.fs->fs_type == FS_FAT32 && djn.sclust == djn.fs->dirbase) ? 0 : djn.sclust;
+									ST_CLUST(dir, dw);
+									djn.fs->wflag = 1;
+								}
+							}
+						}
+						if (res == FR_OK) {
+							res = dir_remove(&djo);		/* Remove old entry */
+							if (res == FR_OK)
+								res = sync(djo.fs);
+						}
+					}
+/* End critical section */
+				}
+			}
+		}
+		FREE_BUF();
+	}
+	LEAVE_FF(djo.fs, res);
+}
+
+#endif /* !_FS_READONLY */
+#endif /* _FS_MINIMIZE == 0 */
+#endif /* _FS_MINIMIZE <= 1 */
+#endif /* _FS_MINIMIZE <= 2 */
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Forward data to the stream directly (available on only tiny cfg)      */
+/*-----------------------------------------------------------------------*/
+#if _USE_FORWARD && _FS_TINY
+
+FRESULT f_forward (
+	FIL *fp, 						/* Pointer to the file object */
+	UINT (*func)(const BYTE*,UINT),	/* Pointer to the streaming function */
+	UINT btr,						/* Number of bytes to forward */
+	UINT *bf						/* Pointer to number of bytes forwarded */
+)
+{
+	FRESULT res;
+	DWORD remain, clst, sect;
+	UINT rcnt;
+	BYTE csect;
+
+
+	*bf = 0;	/* Initialize byte counter */
+
+	res = validate(fp->fs, fp->id);					/* Check validity of the object */
+	if (res != FR_OK) LEAVE_FF(fp->fs, res);
+	if (fp->flag & FA__ERROR)						/* Check error flag */
+		LEAVE_FF(fp->fs, FR_INT_ERR);
+	if (!(fp->flag & FA_READ))						/* Check access mode */
+		LEAVE_FF(fp->fs, FR_DENIED);
+
+	remain = fp->fsize - fp->fptr;
+	if (btr > remain) btr = (UINT)remain;			/* Truncate btr by remaining bytes */
+
+	for ( ;  btr && (*func)(0, 0);					/* Repeat until all data transferred or stream becomes busy */
+		fp->fptr += rcnt, *bf += rcnt, btr -= rcnt) {
+		csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
+		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
+			if (!csect) {							/* On the cluster boundary? */
+				clst = (fp->fptr == 0) ?			/* On the top of the file? */
+					fp->sclust : get_fat(fp->fs, fp->clust);
+				if (clst <= 1) ABORT(fp->fs, FR_INT_ERR);
+				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
+				fp->clust = clst;					/* Update current cluster */
+			}
+		}
+		sect = clust2sect(fp->fs, fp->clust);		/* Get current data sector */
+		if (!sect) ABORT(fp->fs, FR_INT_ERR);
+		sect += csect;
+		if (move_window(fp->fs, sect))				/* Move sector window */
+			ABORT(fp->fs, FR_DISK_ERR);
+		fp->dsect = sect;
+		rcnt = SS(fp->fs) - (WORD)(fp->fptr % SS(fp->fs));	/* Forward data from sector window */
+		if (rcnt > btr) rcnt = btr;
+		rcnt = (*func)(&fp->fs->win[(WORD)fp->fptr % SS(fp->fs)], rcnt);
+		if (!rcnt) ABORT(fp->fs, FR_INT_ERR);
+	}
+
+	LEAVE_FF(fp->fs, FR_OK);
+}
+#endif /* _USE_FORWARD */
+
+
+
+#if _USE_MKFS && !_FS_READONLY
+/*-----------------------------------------------------------------------*/
+/* Create File System on the Drive                                       */
+/*-----------------------------------------------------------------------*/
+#define N_ROOTDIR	512		/* Number of root dir entries for FAT12/16 */
+#define N_FATS		1		/* Number of FAT copies (1 or 2) */
+
+
+FRESULT f_mkfs (
+	BYTE drv,		/* Logical drive number */
+	BYTE sfd,		/* Partitioning rule 0:FDISK, 1:SFD */
+	UINT au			/* Allocation unit size [bytes] */
+)
+{
+	static const WORD vst[] = { 1024,   512,  256,  128,   64,    32,   16,    8,    4,    2,   0};
+	static const WORD cst[] = {32768, 16384, 8192, 4096, 2048, 16384, 8192, 4096, 2048, 1024, 512};
+	BYTE fmt, md, sys, *tbl, pdrv, part;
+	DWORD n_clst, vs, n, wsect;
+	UINT i;
+	DWORD b_vol, b_fat, b_dir, b_data;	/* LBA */
+	DWORD n_vol, n_rsv, n_fat, n_dir;	/* Size */
+	FATFS *fs;
+	DSTATUS stat;
+
+
+	/* Check mounted drive and clear work area */
+	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
+	if (sfd > 1) return FR_INVALID_PARAMETER;
+	if (au & (au - 1)) return FR_INVALID_PARAMETER;
+	fs = FatFs[drv];
+	if (!fs) return FR_NOT_ENABLED;
+	fs->fs_type = 0;
+	pdrv = LD2PD(drv);	/* Physical drive */
+	part = LD2PT(drv);	/* Partition (0:auto detect, 1-4:get from partition table)*/
+
+	/* Get disk statics */
+	stat = disk_initialize(pdrv);
+	if (stat & STA_NOINIT) return FR_NOT_READY;
+	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
+#if _MAX_SS != 512					/* Get disk sector size */
+	if (disk_ioctl(pdrv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK || SS(fs) > _MAX_SS)
+		return FR_DISK_ERR;
+#endif
+	if (_MULTI_PARTITION && part) {
+		/* Get partition information from partition table in the MBR */
+		if (disk_read(pdrv, fs->win, 0, 1) != RES_OK) return FR_DISK_ERR;
+		if (LD_WORD(fs->win+BS_55AA) != 0xAA55) return FR_MKFS_ABORTED;
+		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
+		if (!tbl[4]) return FR_MKFS_ABORTED;	/* No partition? */
+		b_vol = LD_DWORD(tbl+8);	/* Volume start sector */
+		n_vol = LD_DWORD(tbl+12);	/* Volume size */
+	} else {
+		/* Create a partition in this function */
+		if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &n_vol) != RES_OK || n_vol < 128)
+			return FR_DISK_ERR;
+		b_vol = (sfd) ? 0 : 63;		/* Volume start sector */
+		n_vol -= b_vol;				/* Volume size */
+	}
+
+	if (!au) {				/* AU auto selection */
+		vs = n_vol / (2000 / (SS(fs) / 512));
+		for (i = 0; vs < vst[i]; i++) ;
+		au = cst[i];
+	}
+	au /= SS(fs);		/* Number of sectors per cluster */
+	if (au == 0) au = 1;
+	if (au > 128) au = 128;
+
+	/* Pre-compute number of clusters and FAT syb-type */
+	n_clst = n_vol / au;
+	fmt = FS_FAT12;
+	if (n_clst >= MIN_FAT16) fmt = FS_FAT16;
+	if (n_clst >= MIN_FAT32) fmt = FS_FAT32;
+
+	/* Determine offset and size of FAT structure */
+	if (fmt == FS_FAT32) {
+		n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
+		n_rsv = 32;
+		n_dir = 0;
+	} else {
+		n_fat = (fmt == FS_FAT12) ? (n_clst * 3 + 1) / 2 + 3 : (n_clst * 2) + 4;
+		n_fat = (n_fat + SS(fs) - 1) / SS(fs);
+		n_rsv = 1;
+		n_dir = (DWORD)N_ROOTDIR * SZ_DIR / SS(fs);
+	}
+	b_fat = b_vol + n_rsv;				/* FAT area start sector */
+	b_dir = b_fat + n_fat * N_FATS;		/* Directory area start sector */
+	b_data = b_dir + n_dir;				/* Data area start sector */
+	if (n_vol < b_data + au - b_vol) return FR_MKFS_ABORTED;	/* Too small volume */
+
+	/* Align data start sector to erase block boundary (for flash memory media) */
+	if (disk_ioctl(pdrv, GET_BLOCK_SIZE, &n) != RES_OK || !n || n > 32768) n = 1;
+	n = (b_data + n - 1) & ~(n - 1);	/* Next nearest erase block from current data start */
+	n = (n - b_data) / N_FATS;
+	if (fmt == FS_FAT32) {		/* FAT32: Move FAT offset */
+		n_rsv += n;
+		b_fat += n;
+	} else {					/* FAT12/16: Expand FAT size */
+		n_fat += n;
+	}
+
+	/* Determine number of clusters and final check of validity of the FAT sub-type */
+	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
+	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
+		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
+		return FR_MKFS_ABORTED;
+
+	switch (fmt) {	/* Determine system ID for partition table */
+	case FS_FAT12:	sys = 0x01; break;
+	case FS_FAT16:	sys = (n_vol < 0x10000) ? 0x04 : 0x06; break;
+	default: 		sys = 0x0C;
+	}
+
+	if (_MULTI_PARTITION && part) {
+		/* Update system ID in the partition table */
+		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
+		tbl[4] = sys;
+		if (disk_write(pdrv, fs->win, 0, 1) != RES_OK) return FR_DISK_ERR;
+		md = 0xF8;
+	} else {
+		if (sfd) {	/* No patition table (SFD) */
+			md = 0xF0;
+		} else {	/* Create partition table (FDISK) */
+			mem_set(fs->win, 0, SS(fs));
+			tbl = fs->win+MBR_Table;	/* Create partiton table for single partition in the drive */
+			tbl[1] = 1;						/* Partition start head */
+			tbl[2] = 1;						/* Partition start sector */
+			tbl[3] = 0;						/* Partition start cylinder */
+			tbl[4] = sys;					/* System type */
+			tbl[5] = 254;					/* Partition end head */
+			n = (b_vol + n_vol) / 63 / 255;
+			tbl[6] = (BYTE)((n >> 2) | 63);	/* Partiiton end sector */
+			tbl[7] = (BYTE)n;				/* End cylinder */
+			ST_DWORD(tbl+8, 63);			/* Partition start in LBA */
+			ST_DWORD(tbl+12, n_vol);		/* Partition size in LBA */
+			ST_WORD(fs->win+BS_55AA, 0xAA55);	/* MBR signature */
+			if (disk_write(pdrv, fs->win, 0, 1) != RES_OK)	/* Write it to the MBR sector */
+				return FR_DISK_ERR;
+			md = 0xF8;
+		}
+	}
+
+	/* Create BPB in the VBR */
+	tbl = fs->win;							/* Clear sector */
+	mem_set(tbl, 0, SS(fs));
+	mem_cpy(tbl, "\xEB\xFE\x90" "MSDOS5.0", 11);/* Boot jump code, OEM name */
+	i = SS(fs);								/* Sector size */
+	ST_WORD(tbl+BPB_BytsPerSec, i);
+	tbl[BPB_SecPerClus] = (BYTE)au;			/* Sectors per cluster */
+	ST_WORD(tbl+BPB_RsvdSecCnt, n_rsv);		/* Reserved sectors */
+	tbl[BPB_NumFATs] = N_FATS;				/* Number of FATs */
+	i = (fmt == FS_FAT32) ? 0 : N_ROOTDIR;	/* Number of rootdir entries */
+	ST_WORD(tbl+BPB_RootEntCnt, i);
+	if (n_vol < 0x10000) {					/* Number of total sectors */
+		ST_WORD(tbl+BPB_TotSec16, n_vol);
+	} else {
+		ST_DWORD(tbl+BPB_TotSec32, n_vol);
+	}
+	tbl[BPB_Media] = md;					/* Media descriptor */
+	ST_WORD(tbl+BPB_SecPerTrk, 63);			/* Number of sectors per track */
+	ST_WORD(tbl+BPB_NumHeads, 255);			/* Number of heads */
+	ST_DWORD(tbl+BPB_HiddSec, b_vol);		/* Hidden sectors */
+	n = get_fattime();						/* Use current time as VSN */
+	if (fmt == FS_FAT32) {
+		ST_DWORD(tbl+BS_VolID32, n);		/* VSN */
+		ST_DWORD(tbl+BPB_FATSz32, n_fat);	/* Number of sectors per FAT */
+		ST_DWORD(tbl+BPB_RootClus, 2);		/* Root directory start cluster (2) */
+		ST_WORD(tbl+BPB_FSInfo, 1);			/* FSInfo record offset (VBR+1) */
+		ST_WORD(tbl+BPB_BkBootSec, 6);		/* Backup boot record offset (VBR+6) */
+		tbl[BS_DrvNum32] = 0x80;			/* Drive number */
+		tbl[BS_BootSig32] = 0x29;			/* Extended boot signature */
+		mem_cpy(tbl+BS_VolLab32, "NO NAME    " "FAT32   ", 19);	/* Volume label, FAT signature */
+	} else {
+		ST_DWORD(tbl+BS_VolID, n);			/* VSN */
+		ST_WORD(tbl+BPB_FATSz16, n_fat);	/* Number of sectors per FAT */
+		tbl[BS_DrvNum] = 0x80;				/* Drive number */
+		tbl[BS_BootSig] = 0x29;				/* Extended boot signature */
+		mem_cpy(tbl+BS_VolLab, "NO NAME    " "FAT     ", 19);	/* Volume label, FAT signature */
+	}
+	ST_WORD(tbl+BS_55AA, 0xAA55);			/* Signature (Offset is fixed here regardless of sector size) */
+	if (disk_write(pdrv, tbl, b_vol, 1) != RES_OK)	/* Write it to the VBR sector */
+		return FR_DISK_ERR;
+	if (fmt == FS_FAT32)							/* Write backup VBR if needed (VBR+6) */
+		disk_write(pdrv, tbl, b_vol + 6, 1);
+
+	/* Initialize FAT area */
+	wsect = b_fat;
+	for (i = 0; i < N_FATS; i++) {		/* Initialize each FAT copy */
+		mem_set(tbl, 0, SS(fs));			/* 1st sector of the FAT  */
+		n = md;								/* Media descriptor byte */
+		if (fmt != FS_FAT32) {
+			n |= (fmt == FS_FAT12) ? 0x00FFFF00 : 0xFFFFFF00;
+			ST_DWORD(tbl+0, n);				/* Reserve cluster #0-1 (FAT12/16) */
+		} else {
+			n |= 0xFFFFFF00;
+			ST_DWORD(tbl+0, n);				/* Reserve cluster #0-1 (FAT32) */
+			ST_DWORD(tbl+4, 0xFFFFFFFF);
+			ST_DWORD(tbl+8, 0x0FFFFFFF);	/* Reserve cluster #2 for root dir */
+		}
+		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
+			return FR_DISK_ERR;
+		mem_set(tbl, 0, SS(fs));			/* Fill following FAT entries with zero */
+		for (n = 1; n < n_fat; n++) {		/* This loop may take a time on FAT32 volume due to many single sector writes */
+			if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
+				return FR_DISK_ERR;
+		}
+	}
+
+	/* Initialize root directory */
+	i = (fmt == FS_FAT32) ? au : n_dir;
+	do {
+		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
+			return FR_DISK_ERR;
+	} while (--i);
+
+#if _USE_ERASE	/* Erase data area if needed */
+	{
+		DWORD eb[2];
+
+		eb[0] = wsect; eb[1] = wsect + (n_clst - ((fmt == FS_FAT32) ? 1 : 0)) * au - 1;
+		disk_ioctl(pdrv, CTRL_ERASE_SECTOR, eb);
+	}
+#endif
+
+	/* Create FSInfo if needed */
+	if (fmt == FS_FAT32) {
+		ST_DWORD(tbl+FSI_LeadSig, 0x41615252);
+		ST_DWORD(tbl+FSI_StrucSig, 0x61417272);
+		ST_DWORD(tbl+FSI_Free_Count, n_clst - 1);	/* Number of free clusters */
+		ST_DWORD(tbl+FSI_Nxt_Free, 2);				/* Last allocated cluster# */
+		ST_WORD(tbl+BS_55AA, 0xAA55);
+		disk_write(pdrv, tbl, b_vol + 1, 1);	/* Write original (VBR+1) */
+		disk_write(pdrv, tbl, b_vol + 7, 1);	/* Write backup (VBR+7) */
+	}
+
+	return (disk_ioctl(pdrv, CTRL_SYNC, 0) == RES_OK) ? FR_OK : FR_DISK_ERR;
+}
+
+
+#if _MULTI_PARTITION == 2
+/*-----------------------------------------------------------------------*/
+/* Divide Physical Drive                                                 */
+/*-----------------------------------------------------------------------*/
+
+FRESULT f_fdisk (
+	BYTE pdrv,			/* Physical drive number */
+	const DWORD szt[],	/* Pointer to the size table for each partitions */
+	void* work			/* Pointer to the working buffer */
+)
+{
+	UINT i, n, sz_cyl, tot_cyl, b_cyl, e_cyl, p_cyl;
+	BYTE s_hd, e_hd, *p, *buf = (BYTE*)work;
+	DSTATUS stat;
+	DWORD sz_disk, sz_part, s_part;
+
+
+	stat = disk_initialize(pdrv);
+	if (stat & STA_NOINIT) return FR_NOT_READY;
+	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
+	if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &sz_disk)) return FR_DISK_ERR;
+
+	/* Determine CHS in the table regardless of the drive geometry */
+	for (n = 16; n < 256 && sz_disk / n / 63 > 1024; n *= 2) ;
+	if (n == 256) n--;
+	e_hd = n - 1;
+	sz_cyl = 63 * n;
+	tot_cyl = sz_disk / sz_cyl;
+
+	/* Create partition table */
+	mem_set(buf, 0, _MAX_SS);
+	p = buf + MBR_Table; b_cyl = 0;
+	for (i = 0; i < 4; i++, p += SZ_PTE) {
+		p_cyl = (szt[i] <= 100) ? (DWORD)tot_cyl * szt[i] / 100 : szt[i] / sz_cyl;
+		if (!p_cyl) continue;
+		s_part = (DWORD)sz_cyl * b_cyl;
+		sz_part = (DWORD)sz_cyl * p_cyl;
+		if (i == 0) {	/* Exclude first track of cylinder 0 */
+			s_hd = 1;
+			s_part += 63; sz_part -= 63;
+		} else {
+			s_hd = 0;
+		}
+		e_cyl = b_cyl + p_cyl - 1;
+		if (e_cyl >= tot_cyl) return FR_INVALID_PARAMETER;
+
+		/* Set partition table */
+		p[1] = s_hd;						/* Start head */
+		p[2] = (BYTE)((b_cyl >> 2) + 1);	/* Start sector */
+		p[3] = (BYTE)b_cyl;					/* Start cylinder */
+		p[4] = 0x06;						/* System type (temporary setting) */
+		p[5] = e_hd;						/* End head */
+		p[6] = (BYTE)((e_cyl >> 2) + 63);	/* End sector */
+		p[7] = (BYTE)e_cyl;					/* End cylinder */
+		ST_DWORD(p + 8, s_part);			/* Start sector in LBA */
+		ST_DWORD(p + 12, sz_part);			/* Partition size */
+
+		/* Next partition */
+		b_cyl += p_cyl;
+	}
+	ST_WORD(p, 0xAA55);
+
+	/* Write it to the MBR */
+	return (disk_write(pdrv, buf, 0, 1) || disk_ioctl(pdrv, CTRL_SYNC, 0)) ? FR_DISK_ERR : FR_OK;
+}
+
+
+#endif /* _MULTI_PARTITION == 2 */
+#endif /* _USE_MKFS && !_FS_READONLY */
+
+
+
+
+#if _USE_STRFUNC
+/*-----------------------------------------------------------------------*/
+/* Get a string from the file                                            */
+/*-----------------------------------------------------------------------*/
+TCHAR* f_gets (
+	TCHAR* buff,	/* Pointer to the string buffer to read */
+	int len,		/* Size of string buffer (characters) */
+	FIL* fil		/* Pointer to the file object */
+)
+{
+	int n = 0;
+	TCHAR c, *p = buff;
+	BYTE s[2];
+	UINT rc;
+
+
+	while (n < len - 1) {			/* Read bytes until buffer gets filled */
+		f_read(fil, s, 1, &rc);
+		if (rc != 1) break;			/* Break on EOF or error */
+		c = s[0];
+#if _LFN_UNICODE					/* Read a character in UTF-8 encoding */
+		if (c >= 0x80) {
+			if (c < 0xC0) continue;	/* Skip stray trailer */
+			if (c < 0xE0) {			/* Two-byte sequense */
+				f_read(fil, s, 1, &rc);
+				if (rc != 1) break;
+				c = ((c & 0x1F) << 6) | (s[0] & 0x3F);
+				if (c < 0x80) c = '?';
+			} else {
+				if (c < 0xF0) {		/* Three-byte sequense */
+					f_read(fil, s, 2, &rc);
+					if (rc != 2) break;
+					c = (c << 12) | ((s[0] & 0x3F) << 6) | (s[1] & 0x3F);
+					if (c < 0x800) c = '?';
+				} else {			/* Reject four-byte sequense */
+					c = '?';
+				}
+			}
+		}
+#endif
+#if _USE_STRFUNC >= 2
+		if (c == '\r') continue;	/* Strip '\r' */
+#endif
+		*p++ = c;
+		n++;
+		if (c == '\n') break;		/* Break on EOL */
+	}
+	*p = 0;
+	return n ? buff : 0;			/* When no data read (eof or error), return with error. */
+}
+
+
+
+#if !_FS_READONLY
+#include <stdarg.h>
+/*-----------------------------------------------------------------------*/
+/* Put a character to the file                                           */
+/*-----------------------------------------------------------------------*/
+int f_putc (
+	TCHAR c,	/* A character to be output */
+	FIL* fil	/* Pointer to the file object */
+)
+{
+	UINT bw, btw;
+	BYTE s[3];
+
+
+#if _USE_STRFUNC >= 2
+	if (c == '\n') f_putc ('\r', fil);	/* LF -> CRLF conversion */
+#endif
+
+#if _LFN_UNICODE	/* Write the character in UTF-8 encoding */
+	if (c < 0x80) {			/* 7-bit */
+		s[0] = (BYTE)c;
+		btw = 1;
+	} else {
+		if (c < 0x800) {	/* 11-bit */
+			s[0] = (BYTE)(0xC0 | (c >> 6));
+			s[1] = (BYTE)(0x80 | (c & 0x3F));
+			btw = 2;
+		} else {			/* 16-bit */
+			s[0] = (BYTE)(0xE0 | (c >> 12));
+			s[1] = (BYTE)(0x80 | ((c >> 6) & 0x3F));
+			s[2] = (BYTE)(0x80 | (c & 0x3F));
+			btw = 3;
+		}
+	}
+#else				/* Write the character without conversion */
+	s[0] = (BYTE)c;
+	btw = 1;
+#endif
+	f_write(fil, s, btw, &bw);		/* Write the char to the file */
+	return (bw == btw) ? 1 : EOF;	/* Return the result */
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Put a string to the file                                              */
+/*-----------------------------------------------------------------------*/
+int f_puts (
+	const TCHAR* str,	/* Pointer to the string to be output */
+	FIL* fil			/* Pointer to the file object */
+)
+{
+	int n;
+
+
+	for (n = 0; *str; str++, n++) {
+		if (f_putc(*str, fil) == EOF) return EOF;
+	}
+	return n;
+}
+
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Put a formatted string to the file                                    */
+/*-----------------------------------------------------------------------*/
+int f_printf (
+	FIL* fil,			/* Pointer to the file object */
+	const TCHAR* str,	/* Pointer to the format string */
+	...					/* Optional arguments... */
+)
+{
+	va_list arp;
+	BYTE f, r;
+	UINT i, j, w;
+	ULONG v;
+	TCHAR c, d, s[16], *p;
+	int res, chc, cc;
+
+
+	va_start(arp, str);
+
+	for (cc = res = 0; cc != EOF; res += cc) {
+		c = *str++;
+		if (c == 0) break;			/* End of string */
+		if (c != '%') {				/* Non escape character */
+			cc = f_putc(c, fil);
+			if (cc != EOF) cc = 1;
+			continue;
+		}
+		w = f = 0;
+		c = *str++;
+		if (c == '0') {				/* Flag: '0' padding */
+			f = 1; c = *str++;
+		} else {
+			if (c == '-') {			/* Flag: left justified */
+				f = 2; c = *str++;
+			}
+		}
+		while (IsDigit(c)) {		/* Precision */
+			w = w * 10 + c - '0';
+			c = *str++;
+		}
+		if (c == 'l' || c == 'L') {	/* Prefix: Size is long int */
+			f |= 4; c = *str++;
+		}
+		if (!c) break;
+		d = c;
+		if (IsLower(d)) d -= 0x20;
+		switch (d) {				/* Type is... */
+		case 'S' :					/* String */
+			p = va_arg(arp, TCHAR*);
+			for (j = 0; p[j]; j++) ;
+			chc = 0;
+			if (!(f & 2)) {
+				while (j++ < w) chc += (cc = f_putc(' ', fil));
+			}
+			chc += (cc = f_puts(p, fil));
+			while (j++ < w) chc += (cc = f_putc(' ', fil));
+			if (cc != EOF) cc = chc;
+			continue;
+		case 'C' :					/* Character */
+			cc = f_putc((TCHAR)va_arg(arp, int), fil); continue;
+		case 'B' :					/* Binary */
+			r = 2; break;
+		case 'O' :					/* Octal */
+			r = 8; break;
+		case 'D' :					/* Signed decimal */
+		case 'U' :					/* Unsigned decimal */
+			r = 10; break;
+		case 'X' :					/* Hexdecimal */
+			r = 16; break;
+		default:					/* Unknown type (passthrough) */
+			cc = f_putc(c, fil); continue;
+		}
+
+		/* Get an argument and put it in numeral */
+		v = (f & 4) ? (ULONG)va_arg(arp, long) : ((d == 'D') ? (ULONG)(long)va_arg(arp, int) : (ULONG)va_arg(arp, unsigned int));
+		if (d == 'D' && (v & 0x80000000)) {
+			v = 0 - v;
+			f |= 8;
+		}
+		i = 0;
+		do {
+			d = (TCHAR)(v % r); v /= r;
+			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
+			s[i++] = d + '0';
+		} while (v && i < sizeof(s) / sizeof(s[0]));
+		if (f & 8) s[i++] = '-';
+		j = i; d = (f & 1) ? '0' : ' ';
+		res = 0;
+		while (!(f & 2) && j++ < w) res += (cc = f_putc(d, fil));
+		do res += (cc = f_putc(s[--i], fil)); while(i);
+		while (j++ < w) res += (cc = f_putc(' ', fil));
+		if (cc != EOF) cc = res;
+	}
+
+	va_end(arp);
+	return (cc == EOF) ? cc : res;
+}
+
+#endif /* !_FS_READONLY */
+#endif /* _USE_STRFUNC */
+
+
+DWORD get_fattime (void)
+{
+  return (1 << 21) | (1 << 16);
+}
diff --git a/cpu/jennic/dev/ff.h b/cpu/jennic/dev/ff.h
new file mode 100644
index 0000000..a8576b3
--- /dev/null
+++ b/cpu/jennic/dev/ff.h
@@ -0,0 +1,356 @@
+/*---------------------------------------------------------------------------/
+/  FatFs - FAT file system module include file  R0.09     (C)ChaN, 2011
+/----------------------------------------------------------------------------/
+/ FatFs module is a generic FAT file system module for small embedded systems.
+/ This is a free software that opened for education, research and commercial
+/ developments under license policy of following trems.
+/
+/  Copyright (C) 2011, ChaN, all right reserved.
+/
+/ * The FatFs module is a free software and there is NO WARRANTY.
+/ * No restriction on use. You can use, modify and redistribute it for
+/   personal, non-profit or commercial product UNDER YOUR RESPONSIBILITY.
+/ * Redistributions of source code must retain the above copyright notice.
+/
+/----------------------------------------------------------------------------*/
+
+#ifndef _FATFS
+#define _FATFS	6502	/* Revision ID */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "ffconf.h"		/* FatFs configuration options */
+
+/* These types must be 16-bit, 32-bit or larger integer */
+typedef int				INT;
+typedef unsigned int	UINT;
+
+/* These types must be 8-bit integer */
+typedef char			CHAR;
+typedef unsigned char	UCHAR;
+typedef unsigned char	BYTE;
+
+/* These types must be 16-bit integer */
+typedef short			SHORT;
+typedef unsigned short	USHORT;
+typedef unsigned short	WORD;
+typedef unsigned short	WCHAR;
+
+/* These types must be 32-bit integer */
+typedef long			LONG;
+typedef unsigned long	ULONG;
+typedef unsigned long	DWORD;
+
+#if _FATFS != _FFCONF
+#error Wrong configuration file (ffconf.h).
+#endif
+
+
+
+/* Definitions of volume management */
+
+#if _MULTI_PARTITION		/* Multiple partition configuration */
+typedef struct {
+	BYTE pd;	/* Physical drive number */
+	BYTE pt;	/* Partition: 0:Auto detect, 1-4:Forced partition) */
+} PARTITION;
+extern PARTITION VolToPart[];	/* Volume - Partition resolution table */
+#define LD2PD(vol) (VolToPart[vol].pd)	/* Get physical drive number */
+#define LD2PT(vol) (VolToPart[vol].pt)	/* Get partition index */
+
+#else						/* Single partition configuration */
+#define LD2PD(vol) (vol)	/* Each logical drive is bound to the same physical drive number */
+#define LD2PT(vol) 0		/* Always mounts the 1st partition or in SFD */
+
+#endif
+
+
+
+/* Type of path name strings on FatFs API */
+
+#if _LFN_UNICODE			/* Unicode string */
+#if !_USE_LFN
+#error _LFN_UNICODE must be 0 in non-LFN cfg.
+#endif
+#ifndef _INC_TCHAR
+typedef WCHAR TCHAR;
+#define _T(x) L ## x
+#define _TEXT(x) L ## x
+#endif
+
+#else						/* ANSI/OEM string */
+#ifndef _INC_TCHAR
+typedef char TCHAR;
+#define _T(x) x
+#define _TEXT(x) x
+#endif
+
+#endif
+
+
+
+/* File system object structure (FATFS) */
+
+typedef struct {
+	BYTE	fs_type;		/* FAT sub-type (0:Not mounted) */
+	BYTE	drv;			/* Physical drive number */
+	BYTE	csize;			/* Sectors per cluster (1,2,4...128) */
+	BYTE	n_fats;			/* Number of FAT copies (1,2) */
+	BYTE	wflag;			/* win[] dirty flag (1:must be written back) */
+	BYTE	fsi_flag;		/* fsinfo dirty flag (1:must be written back) */
+	WORD	id;				/* File system mount ID */
+	WORD	n_rootdir;		/* Number of root directory entries (FAT12/16) */
+#if _MAX_SS != 512
+	WORD	ssize;			/* Bytes per sector (512, 1024, 2048 or 4096) */
+#endif
+#if _FS_REENTRANT
+	_SYNC_t	sobj;			/* Identifier of sync object */
+#endif
+#if !_FS_READONLY
+	DWORD	last_clust;		/* Last allocated cluster */
+	DWORD	free_clust;		/* Number of free clusters */
+	DWORD	fsi_sector;		/* fsinfo sector (FAT32) */
+#endif
+#if _FS_RPATH
+	DWORD	cdir;			/* Current directory start cluster (0:root) */
+#endif
+	DWORD	n_fatent;		/* Number of FAT entries (= number of clusters + 2) */
+	DWORD	fsize;			/* Sectors per FAT */
+	DWORD	fatbase;		/* FAT start sector */
+	DWORD	dirbase;		/* Root directory start sector (FAT32:Cluster#) */
+	DWORD	database;		/* Data start sector */
+	DWORD	winsect;		/* Current sector appearing in the win[] */
+	BYTE	win[_MAX_SS];	/* Disk access window for Directory, FAT (and Data on tiny cfg) */
+} FATFS;
+
+
+
+/* File object structure (FIL) */
+
+typedef struct {
+	FATFS*	fs;				/* Pointer to the owner file system object */
+	WORD	id;				/* Owner file system mount ID */
+	BYTE	flag;			/* File status flags */
+	BYTE	pad1;
+	DWORD	fptr;			/* File read/write pointer (0 on file open) */
+	DWORD	fsize;			/* File size */
+	DWORD	sclust;			/* File start cluster (0 when fsize==0) */
+	DWORD	clust;			/* Current cluster */
+	DWORD	dsect;			/* Current data sector */
+#if !_FS_READONLY
+	DWORD	dir_sect;		/* Sector containing the directory entry */
+	BYTE*	dir_ptr;		/* Ponter to the directory entry in the window */
+#endif
+#if _USE_FASTSEEK
+	DWORD*	cltbl;			/* Pointer to the cluster link map table (null on file open) */
+#endif
+#if _FS_SHARE
+	UINT	lockid;			/* File lock ID (index of file semaphore table) */
+#endif
+#if !_FS_TINY
+	BYTE	buf[_MAX_SS];	/* File data read/write buffer */
+#endif
+} FIL;
+
+
+
+/* Directory object structure (DIR) */
+
+typedef struct {
+	FATFS*	fs;				/* Pointer to the owner file system object */
+	WORD	id;				/* Owner file system mount ID */
+	WORD	index;			/* Current read/write index number */
+	DWORD	sclust;			/* Table start cluster (0:Root dir) */
+	DWORD	clust;			/* Current cluster */
+	DWORD	sect;			/* Current sector */
+	BYTE*	dir;			/* Pointer to the current SFN entry in the win[] */
+	BYTE*	fn;				/* Pointer to the SFN (in/out) {file[8],ext[3],status[1]} */
+#if _USE_LFN
+	WCHAR*	lfn;			/* Pointer to the LFN working buffer */
+	WORD	lfn_idx;		/* Last matched LFN index number (0xFFFF:No LFN) */
+#endif
+} DIR;
+
+
+
+/* File status structure (FILINFO) */
+
+typedef struct {
+	DWORD	fsize;			/* File size */
+	WORD	fdate;			/* Last modified date */
+	WORD	ftime;			/* Last modified time */
+	BYTE	fattrib;		/* Attribute */
+	TCHAR	fname[13];		/* Short file name (8.3 format) */
+#if _USE_LFN
+	TCHAR*	lfname;			/* Pointer to the LFN buffer */
+	UINT 	lfsize;			/* Size of LFN buffer in TCHAR */
+#endif
+} FILINFO;
+
+
+
+/* File function return code (FRESULT) */
+
+typedef enum {
+	FR_OK = 0,				/* (0) Succeeded */
+	FR_DISK_ERR,			/* (1) A hard error occured in the low level disk I/O layer */
+	FR_INT_ERR,				/* (2) Assertion failed */
+	FR_NOT_READY,			/* (3) The physical drive cannot work */
+	FR_NO_FILE,				/* (4) Could not find the file */
+	FR_NO_PATH,				/* (5) Could not find the path */
+	FR_INVALID_NAME,		/* (6) The path name format is invalid */
+	FR_DENIED,				/* (7) Acces denied due to prohibited access or directory full */
+	FR_EXIST,				/* (8) Acces denied due to prohibited access */
+	FR_INVALID_OBJECT,		/* (9) The file/directory object is invalid */
+	FR_WRITE_PROTECTED,		/* (10) The physical drive is write protected */
+	FR_INVALID_DRIVE,		/* (11) The logical drive number is invalid */
+	FR_NOT_ENABLED,			/* (12) The volume has no work area */
+	FR_NO_FILESYSTEM,		/* (13) There is no valid FAT volume */
+	FR_MKFS_ABORTED,		/* (14) The f_mkfs() aborted due to any parameter error */
+	FR_TIMEOUT,				/* (15) Could not get a grant to access the volume within defined period */
+	FR_LOCKED,				/* (16) The operation is rejected according to the file shareing policy */
+	FR_NOT_ENOUGH_CORE,		/* (17) LFN working buffer could not be allocated */
+	FR_TOO_MANY_OPEN_FILES,	/* (18) Number of open files > _FS_SHARE */
+	FR_INVALID_PARAMETER	/* (19) Given parameter is invalid */
+} FRESULT;
+
+
+
+/*--------------------------------------------------------------*/
+/* FatFs module application interface                           */
+
+FRESULT f_mount (BYTE, FATFS*);						/* Mount/Unmount a logical drive */
+FRESULT f_open (FIL*, const TCHAR*, BYTE);			/* Open or create a file */
+FRESULT f_read (FIL*, void*, UINT, UINT*);			/* Read data from a file */
+FRESULT f_lseek (FIL*, DWORD);						/* Move file pointer of a file object */
+FRESULT f_close (FIL*);								/* Close an open file object */
+FRESULT f_opendir (DIR*, const TCHAR*);				/* Open an existing directory */
+FRESULT f_readdir (DIR*, FILINFO*);					/* Read a directory item */
+FRESULT f_stat (const TCHAR*, FILINFO*);			/* Get file status */
+FRESULT f_write (FIL*, const void*, UINT, UINT*);	/* Write data to a file */
+FRESULT f_getfree (const TCHAR*, DWORD*, FATFS**);	/* Get number of free clusters on the drive */
+FRESULT f_truncate (FIL*);							/* Truncate file */
+FRESULT f_sync (FIL*);								/* Flush cached data of a writing file */
+FRESULT f_unlink (const TCHAR*);					/* Delete an existing file or directory */
+FRESULT	f_mkdir (const TCHAR*);						/* Create a new directory */
+FRESULT f_chmod (const TCHAR*, BYTE, BYTE);			/* Change attriburte of the file/dir */
+FRESULT f_utime (const TCHAR*, const FILINFO*);		/* Change timestamp of the file/dir */
+FRESULT f_rename (const TCHAR*, const TCHAR*);		/* Rename/Move a file or directory */
+FRESULT f_chdrive (BYTE);							/* Change current drive */
+FRESULT f_chdir (const TCHAR*);						/* Change current directory */
+FRESULT f_getcwd (TCHAR*, UINT);					/* Get current directory */
+FRESULT f_forward (FIL*, UINT(*)(const BYTE*,UINT), UINT, UINT*);	/* Forward data to the stream */
+FRESULT f_mkfs (BYTE, BYTE, UINT);					/* Create a file system on the drive */
+FRESULT	f_fdisk (BYTE, const DWORD[], void*);		/* Divide a physical drive into some partitions */
+int f_putc (TCHAR, FIL*);							/* Put a character to the file */
+int f_puts (const TCHAR*, FIL*);					/* Put a string to the file */
+int f_printf (FIL*, const TCHAR*, ...);				/* Put a formatted string to the file */
+TCHAR* f_gets (TCHAR*, int, FIL*);					/* Get a string from the file */
+
+#define f_eof(fp) (((fp)->fptr == (fp)->fsize) ? 1 : 0)
+#define f_error(fp) (((fp)->flag & FA__ERROR) ? 1 : 0)
+#define f_tell(fp) ((fp)->fptr)
+#define f_size(fp) ((fp)->fsize)
+
+#ifndef EOF
+#define EOF (-1)
+#endif
+
+
+
+
+/*--------------------------------------------------------------*/
+/* Additional user defined functions                            */
+
+/* RTC function */
+#if !_FS_READONLY
+DWORD get_fattime (void);
+#endif
+
+/* Unicode support functions */
+#if _USE_LFN						/* Unicode - OEM code conversion */
+WCHAR ff_convert (WCHAR, UINT);		/* OEM-Unicode bidirectional conversion */
+WCHAR ff_wtoupper (WCHAR);			/* Unicode upper-case conversion */
+#if _USE_LFN == 3					/* Memory functions */
+void* ff_memalloc (UINT);			/* Allocate memory block */
+void ff_memfree (void*);			/* Free memory block */
+#endif
+#endif
+
+/* Sync functions */
+#if _FS_REENTRANT 
+int ff_cre_syncobj (BYTE, _SYNC_t*);/* Create a sync object */
+int ff_req_grant (_SYNC_t);			/* Lock sync object */
+void ff_rel_grant (_SYNC_t);		/* Unlock sync object */
+int ff_del_syncobj (_SYNC_t);		/* Delete a sync object */
+#endif
+
+
+
+
+/*--------------------------------------------------------------*/
+/* Flags and offset address                                     */
+
+
+/* File access control and file status flags (FIL.flag) */
+
+#define	FA_READ				0x01
+#define	FA_OPEN_EXISTING	0x00
+#define FA__ERROR			0x80
+
+#if !_FS_READONLY
+#define	FA_WRITE			0x02
+#define	FA_CREATE_NEW		0x04
+#define	FA_CREATE_ALWAYS	0x08
+#define	FA_OPEN_ALWAYS		0x10
+#define FA__WRITTEN			0x20
+#define FA__DIRTY			0x40
+#endif
+
+
+/* FAT sub type (FATFS.fs_type) */
+
+#define FS_FAT12	1
+#define FS_FAT16	2
+#define FS_FAT32	3
+
+
+/* File attribute bits for directory entry */
+
+#define	AM_RDO	0x01	/* Read only */
+#define	AM_HID	0x02	/* Hidden */
+#define	AM_SYS	0x04	/* System */
+#define	AM_VOL	0x08	/* Volume label */
+#define AM_LFN	0x0F	/* LFN entry */
+#define AM_DIR	0x10	/* Directory */
+#define AM_ARC	0x20	/* Archive */
+#define AM_MASK	0x3F	/* Mask of defined bits */
+
+
+/* Fast seek feature */
+#define CREATE_LINKMAP	0xFFFFFFFF
+
+
+
+/*--------------------------------*/
+/* Multi-byte word access macros  */
+
+#if _WORD_ACCESS == 1	/* Enable word access to the FAT structure */
+#define	LD_WORD(ptr)		(WORD)(*(WORD*)(BYTE*)(ptr))
+#define	LD_DWORD(ptr)		(DWORD)(*(DWORD*)(BYTE*)(ptr))
+#define	ST_WORD(ptr,val)	*(WORD*)(BYTE*)(ptr)=(WORD)(val)
+#define	ST_DWORD(ptr,val)	*(DWORD*)(BYTE*)(ptr)=(DWORD)(val)
+#else					/* Use byte-by-byte access to the FAT structure */
+#define	LD_WORD(ptr)		(WORD)(((WORD)*((BYTE*)(ptr)+1)<<8)|(WORD)*(BYTE*)(ptr))
+#define	LD_DWORD(ptr)		(DWORD)(((DWORD)*((BYTE*)(ptr)+3)<<24)|((DWORD)*((BYTE*)(ptr)+2)<<16)|((WORD)*((BYTE*)(ptr)+1)<<8)|*(BYTE*)(ptr))
+#define	ST_WORD(ptr,val)	*(BYTE*)(ptr)=(BYTE)(val); *((BYTE*)(ptr)+1)=(BYTE)((WORD)(val)>>8)
+#define	ST_DWORD(ptr,val)	*(BYTE*)(ptr)=(BYTE)(val); *((BYTE*)(ptr)+1)=(BYTE)((WORD)(val)>>8); *((BYTE*)(ptr)+2)=(BYTE)((DWORD)(val)>>16); *((BYTE*)(ptr)+3)=(BYTE)((DWORD)(val)>>24)
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _FATFS */
diff --git a/cpu/jennic/dev/ffconf.h b/cpu/jennic/dev/ffconf.h
new file mode 100644
index 0000000..df19c97
--- /dev/null
+++ b/cpu/jennic/dev/ffconf.h
@@ -0,0 +1,190 @@
+/*---------------------------------------------------------------------------/
+/  FatFs - FAT file system module configuration file  R0.09  (C)ChaN, 2011
+/----------------------------------------------------------------------------/
+/
+/ CAUTION! Do not forget to make clean the project after any changes to
+/ the configuration options.
+/
+/----------------------------------------------------------------------------*/
+#ifndef _FFCONF 
+#define _FFCONF 6502	/* Revision ID */
+
+
+/*---------------------------------------------------------------------------/
+/ Functions and Buffer Configurations
+/----------------------------------------------------------------------------*/
+
+#define	_FS_TINY		1	/* 0:Normal or 1:Tiny */
+/* When _FS_TINY is set to 1, FatFs uses the sector buffer in the file system
+/  object instead of the sector buffer in the individual file object for file
+/  data transfer. This reduces memory consumption 512 bytes each file object. */
+
+
+#define _FS_READONLY	0	/* 0:Read/Write or 1:Read only */
+/* Setting _FS_READONLY to 1 defines read only configuration. This removes
+/  writing functions, f_write, f_sync, f_unlink, f_mkdir, f_chmod, f_rename,
+/  f_truncate and useless f_getfree. */
+
+
+#define _FS_MINIMIZE	2	/* 0 to 3 */
+/* The _FS_MINIMIZE option defines minimization level to remove some functions.
+/
+/   0: Full function.
+/   1: f_stat, f_getfree, f_unlink, f_mkdir, f_chmod, f_truncate and f_rename
+/      are removed.
+/   2: f_opendir and f_readdir are removed in addition to 1.
+/   3: f_lseek is removed in addition to 2. */
+
+
+#define	_USE_STRFUNC	0	/* 0:Disable or 1-2:Enable */
+/* To enable string functions, set _USE_STRFUNC to 1 or 2. */
+
+
+#define	_USE_MKFS		0	/* 0:Disable or 1:Enable */
+/* To enable f_mkfs function, set _USE_MKFS to 1 and set _FS_READONLY to 0 */
+
+
+#define	_USE_FORWARD	0	/* 0:Disable or 1:Enable */
+/* To enable f_forward function, set _USE_FORWARD to 1 and set _FS_TINY to 1. */
+
+
+#define	_USE_FASTSEEK	0	/* 0:Disable or 1:Enable */
+/* To enable fast seek feature, set _USE_FASTSEEK to 1. */
+
+
+
+/*---------------------------------------------------------------------------/
+/ Locale and Namespace Configurations
+/----------------------------------------------------------------------------*/
+
+#define _CODE_PAGE	932
+/* The _CODE_PAGE specifies the OEM code page to be used on the target system.
+/  Incorrect setting of the code page can cause a file open failure.
+/
+/   932  - Japanese Shift-JIS (DBCS, OEM, Windows)
+/   936  - Simplified Chinese GBK (DBCS, OEM, Windows)
+/   949  - Korean (DBCS, OEM, Windows)
+/   950  - Traditional Chinese Big5 (DBCS, OEM, Windows)
+/   1250 - Central Europe (Windows)
+/   1251 - Cyrillic (Windows)
+/   1252 - Latin 1 (Windows)
+/   1253 - Greek (Windows)
+/   1254 - Turkish (Windows)
+/   1255 - Hebrew (Windows)
+/   1256 - Arabic (Windows)
+/   1257 - Baltic (Windows)
+/   1258 - Vietnam (OEM, Windows)
+/   437  - U.S. (OEM)
+/   720  - Arabic (OEM)
+/   737  - Greek (OEM)
+/   775  - Baltic (OEM)
+/   850  - Multilingual Latin 1 (OEM)
+/   858  - Multilingual Latin 1 + Euro (OEM)
+/   852  - Latin 2 (OEM)
+/   855  - Cyrillic (OEM)
+/   866  - Russian (OEM)
+/   857  - Turkish (OEM)
+/   862  - Hebrew (OEM)
+/   874  - Thai (OEM, Windows)
+/	1    - ASCII only (Valid for non LFN cfg.)
+*/
+
+
+#define	_USE_LFN	0		/* 0 to 3 */
+#define	_MAX_LFN	255		/* Maximum LFN length to handle (12 to 255) */
+/* The _USE_LFN option switches the LFN support.
+/
+/   0: Disable LFN feature. _MAX_LFN and _LFN_UNICODE have no effect.
+/   1: Enable LFN with static working buffer on the BSS. Always NOT reentrant.
+/   2: Enable LFN with dynamic working buffer on the STACK.
+/   3: Enable LFN with dynamic working buffer on the HEAP.
+/
+/  The LFN working buffer occupies (_MAX_LFN + 1) * 2 bytes. To enable LFN,
+/  Unicode handling functions ff_convert() and ff_wtoupper() must be added
+/  to the project. When enable to use heap, memory control functions
+/  ff_memalloc() and ff_memfree() must be added to the project. */
+
+
+#define	_LFN_UNICODE	0	/* 0:ANSI/OEM or 1:Unicode */
+/* To switch the character code set on FatFs API to Unicode,
+/  enable LFN feature and set _LFN_UNICODE to 1. */
+
+
+#define _FS_RPATH		0	/* 0 to 2 */
+/* The _FS_RPATH option configures relative path feature.
+/
+/   0: Disable relative path feature and remove related functions.
+/   1: Enable relative path. f_chdrive() and f_chdir() are available.
+/   2: f_getcwd() is available in addition to 1.
+/
+/  Note that output of the f_readdir fnction is affected by this option. */
+
+
+
+/*---------------------------------------------------------------------------/
+/ Physical Drive Configurations
+/----------------------------------------------------------------------------*/
+
+#define _VOLUMES	1
+/* Number of volumes (logical drives) to be used. */
+
+
+#define	_MAX_SS		512		/* 512, 1024, 2048 or 4096 */
+/* Maximum sector size to be handled.
+/  Always set 512 for memory card and hard disk but a larger value may be
+/  required for on-board flash memory, floppy disk and optical disk.
+/  When _MAX_SS is larger than 512, it configures FatFs to variable sector size
+/  and GET_SECTOR_SIZE command must be implememted to the disk_ioctl function. */
+
+
+#define	_MULTI_PARTITION	0	/* 0:Single partition, 1/2:Enable multiple partition */
+/* When set to 0, each volume is bound to the same physical drive number and
+/ it can mount only first primaly partition. When it is set to 1, each volume
+/ is tied to the partitions listed in VolToPart[]. */
+
+
+#define	_USE_ERASE	0	/* 0:Disable or 1:Enable */
+/* To enable sector erase feature, set _USE_ERASE to 1. CTRL_ERASE_SECTOR command
+/  should be added to the disk_ioctl functio. */
+
+
+
+/*---------------------------------------------------------------------------/
+/ System Configurations
+/----------------------------------------------------------------------------*/
+
+#define _WORD_ACCESS	0	/* 0 or 1 */
+/* Set 0 first and it is always compatible with all platforms. The _WORD_ACCESS
+/  option defines which access method is used to the word data on the FAT volume.
+/
+/   0: Byte-by-byte access.
+/   1: Word access. Do not choose this unless following condition is met.
+/
+/  When the byte order on the memory is big-endian or address miss-aligned word
+/  access results incorrect behavior, the _WORD_ACCESS must be set to 0.
+/  If it is not the case, the value can also be set to 1 to improve the
+/  performance and code size.
+*/
+
+
+/* A header file that defines sync object types on the O/S, such as
+/  windows.h, ucos_ii.h and semphr.h, must be included prior to ff.h. */
+
+#define _FS_REENTRANT	0		/* 0:Disable or 1:Enable */
+#define _FS_TIMEOUT		1000	/* Timeout period in unit of time ticks */
+#define	_SYNC_t			HANDLE	/* O/S dependent type of sync object. e.g. HANDLE, OS_EVENT*, ID and etc.. */
+
+/* The _FS_REENTRANT option switches the reentrancy (thread safe) of the FatFs module.
+/
+/   0: Disable reentrancy. _SYNC_t and _FS_TIMEOUT have no effect.
+/   1: Enable reentrancy. Also user provided synchronization handlers,
+/      ff_req_grant, ff_rel_grant, ff_del_syncobj and ff_cre_syncobj
+/      function must be added to the project. */
+
+
+#define	_FS_SHARE	0	/* 0:Disable or >=1:Enable */
+/* To enable file shareing feature, set _FS_SHARE to 1 or greater. The value
+   defines how many files can be opened simultaneously. */
+
+
+#endif /* _FFCONFIG */
diff --git a/cpu/jennic/dev/hrclock.h b/cpu/jennic/dev/hrclock.h
index bbc32fe..962f6cf 100644
--- a/cpu/jennic/dev/hrclock.h
+++ b/cpu/jennic/dev/hrclock.h
@@ -41,4 +41,16 @@ typedef uint64_t hrclock_t;
 /* return current time in nano-seconds */
 hrclock_t clock_hrtime();
 
+#ifdef JENNIC_CONF_TIMESYNC
+#define UIP_ICMP6_TIMESTAMP  ((hrclock_t *)&uip_buf[uip_l2_l3_icmp_hdr_len])
+#define ICMP6_TIMESYNC 250
+
+uint8_t clock_synced();
+
+hrclock_t clock_synced_hrtime();
+
+void clock_synchronize();
+
+#endif
+
 #endif /* CPU/JENNIC/DEV/HRCLOCK_H_ */
diff --git a/cpu/jennic/dev/sd.c b/cpu/jennic/dev/sd.c
new file mode 100644
index 0000000..d00cbcd
--- /dev/null
+++ b/cpu/jennic/dev/sd.c
@@ -0,0 +1,396 @@
+/*-----------------------------------------------------------------------*/
+/* Low level disk I/O module skeleton for Petit FatFs (C)ChaN, 2009      */
+/*-----------------------------------------------------------------------*/
+
+#include "sd.h"
+#include "contiki.h"
+#include "AppHardwareApi.h"
+
+#define LOWER_CS() do { vAHI_SpiWaitBusy(); vAHI_SpiSelect(1<<1); vAHI_SpiWaitBusy(); } while(0)
+#define RAISE_CS() do { vAHI_SpiWaitBusy(); vAHI_SpiSelect(0); vAHI_SpiWaitBusy(); } while(0)
+
+/*-----------------------------------------------------------------------*/
+/* Initialize Disk Drive                                                 */
+/*-----------------------------------------------------------------------*/
+
+#define DEBUG 0
+
+#include <stdio.h>
+#if DEBUG != 0
+#define PRINTF(...) printf(__VA_ARGS__)
+#else
+#define PRINTF(...)
+#endif
+
+#ifndef MIN 
+#define MIN(a, b)_((a) < (b) ? (a) : (b))
+#endif /* MIN */
+
+#define SDCARD_SLAVE E_AHI_SPIM_SLAVE_ENBLE_0
+
+/* SD commands */
+#define GO_IDLE_STATE     0
+#define SEND_OP_COND      1
+#define SWITCH_FUNC       6
+#define SEND_IF_COND      8
+#define SEND_CSD          9
+#define SEND_CID          10
+#define STOP_TRANSMISSION 12
+#define SEND_STATUS       13
+#define SET_BLOCKLEN      16
+#define READ_SINGLE_BLOCK 17
+#define WRITE_BLOCK       24
+#define APP_CMD           55
+#define READ_OCR          58
+#define SPI_IDLE          0xff
+
+#define APP_SEND_OP_COND  41
+
+/* SD response lengths. */
+#define R1 1
+#define R2 2
+#define R3 5
+#define R7 5
+
+#define START_BLOCK_TOKEN 0xfe
+
+/* Status codes returned after writing a block. */
+#define DATA_ACCEPTED 2
+#define DATA_CRC_ERROR 5
+#define DATA_WRITE_ERROR 6
+
+#define SD_TRANSACTION_ATTEMPTS		1024
+#define SD_READ_RESPONSE_ATTEMPTS	8
+#define SD_READ_BLOCK_ATTEMPTS		2
+
+#define SD_DEFAULT_BLOCK_SIZE		512
+
+static uint16_t address_mult;
+static uint8_t inited = 0;
+
+static void command(uint8_t cmd, uint32_t argument)
+{
+  uint8_t req[6], i;
+
+  req[0] = 0x40 | cmd;
+  req[1] = argument >> 24;
+  req[2] = argument >> 16;
+  req[3] = argument >> 8;
+  req[4] = argument;
+  if (cmd == GO_IDLE_STATE)
+    req[5] = 0x95;
+  else if (cmd == SEND_IF_COND)
+    req[5] = 0x87;
+  else
+    req[5] = 0xff;
+
+  for (i=0; i<sizeof(req); i++) 
+  {
+    vAHI_SpiStartTransfer8(req[i]);
+    vAHI_SpiWaitBusy(); 
+  }
+}
+
+static void transaction(uint8_t cmd, uint32_t argument, uint8_t response_type, uint8_t * response)
+{
+  uint8_t i;
+
+  LOWER_CS();
+  
+  /* send command */
+  command(cmd, argument);
+
+  /* wait for response */
+  for (i = 0; i < SD_READ_RESPONSE_ATTEMPTS; i++)
+  {
+    vAHI_SpiStartTransfer8(SPI_IDLE);
+    vAHI_SpiWaitBusy(); 
+    response[0] = u8AHI_SpiReadTransfer8();
+    if (!(response[0] & 0x80)) //check for response
+      break;
+  }
+  for (i = 1; i < response_type; i++)
+  {
+    vAHI_SpiStartTransfer8(SPI_IDLE);
+    vAHI_SpiWaitBusy(); 
+    response[i] = u8AHI_SpiReadTransfer8();
+  }
+  RAISE_CS();
+
+  /* one pause cycle */
+  vAHI_SpiStartTransfer8(SPI_IDLE);
+  vAHI_SpiWaitBusy();
+}
+
+/*init disk*/
+DSTATUS disk_initialize (BYTE drive)
+{
+  uint8_t response[R7];
+  uint16_t i;
+  uint8_t sdhc = 0;
+  uint8_t mmc = 0;
+
+  /* only drive 0 allowed */
+  if (drive)
+    return STA_NODISK;
+
+  /* init with slow SPI speed */
+  vAHI_SpiConfigure(2,   // number of spi slave select line
+                    E_AHI_SPIM_MSB_FIRST,
+                    0,0, // polarity and phase
+                    63,   // max clock divisor
+                    E_AHI_SPIM_INT_DISABLE,
+                    E_AHI_SPIM_AUTOSLAVE_DSABL);
+
+  /* init cycles */
+  for (i = 0; i < 100; i++)
+  {
+    vAHI_SpiStartTransfer8(0xff);
+    vAHI_SpiWaitBusy();
+  }
+
+  /* software reset */
+  transaction(GO_IDLE_STATE, 0, R1, response);
+  if(!(response[0] & 0x01))
+  {
+    return STA_NOINIT;
+    RAISE_CS();
+  }
+
+  /* SDHC test */
+  transaction(SEND_IF_COND, 0x000001aa, R7, response);
+  if (!(response[0] & 0x04) && response[3]  == 0x01 && response[4] == 0xaa)
+    sdhc = 1;
+
+  /* wake up */
+  for (i = 0; i < SD_TRANSACTION_ATTEMPTS; i++)
+  {
+    if (mmc)
+      transaction(SEND_OP_COND, 0, R1, response);
+    else
+    {
+      transaction(APP_CMD, 0, R1, response);
+      transaction(APP_SEND_OP_COND, 0x40000000 * sdhc, R1, response);
+      if (response[0] & 0x04)
+        mmc = 1;
+    }
+    if (!(response[0] & 0x01))
+      break;
+  }
+  if (response[0] & 0x01)
+  {
+    return STA_NOINIT;
+    RAISE_CS();
+  }
+
+  /* read OCR */
+  transaction(READ_OCR, 0, R3, response);
+  if (!(response[1] & 0x80))
+  {
+    return STA_NOINIT;
+    RAISE_CS();
+  }
+
+  /* byte or block address */
+  if (response[1] & 0x40)
+    address_mult = 1;
+  else
+  {
+    address_mult = SD_DEFAULT_BLOCK_SIZE;
+    transaction(SET_BLOCKLEN, SD_DEFAULT_BLOCK_SIZE, R1, response);
+  }    
+
+  RAISE_CS();
+
+  inited = 1;
+
+  /* continue at high speed */
+  vAHI_SpiConfigure(2,   // number of spi slave select line
+                    E_AHI_SPIM_MSB_FIRST,
+                    0,0, // polarity and phase
+                    0,   // min clock divisor
+                    E_AHI_SPIM_INT_DISABLE,
+                    E_AHI_SPIM_AUTOSLAVE_DSABL);
+
+
+  return 0;
+}
+
+DSTATUS disk_status (BYTE drive)
+{
+  if (drive)
+    return STA_NODISK;
+  else if (!inited)
+    return STA_NOINIT;
+  return 0;
+}
+
+/* read multiple sectors */
+DRESULT disk_read (BYTE drive, BYTE* buffer, DWORD start_sector, BYTE sector_count)
+{
+  /* only drive 0 allowed */
+  if (drive)
+    return RES_PARERR;
+  
+  uint8_t temp;
+  uint16_t i, n;
+  for (n = 0; n < sector_count; n++)
+  {
+    uint32_t argument = (start_sector + n) * address_mult;
+
+    LOWER_CS();
+
+    command(READ_SINGLE_BLOCK, argument);
+  
+    /* wait for response */
+    for (i = 0; i < SD_READ_RESPONSE_ATTEMPTS; i++) {
+      vAHI_SpiStartTransfer8(SPI_IDLE);
+      vAHI_SpiWaitBusy(); 
+
+      temp = u8AHI_SpiReadTransfer8();
+      if (!temp)
+        break;
+    }
+    if (temp) {
+      RAISE_CS();
+      return RES_NOTRDY;
+    }
+
+    /* wait for start token */
+    for (i = 0; i < SD_TRANSACTION_ATTEMPTS; i++) {
+      vAHI_SpiStartTransfer8(SPI_IDLE);
+      vAHI_SpiWaitBusy(); 
+      temp = u8AHI_SpiReadTransfer8();
+      if(temp == START_BLOCK_TOKEN || (temp > 0 && temp <= 8))
+        break;
+    }
+
+    if (temp == START_BLOCK_TOKEN) {
+      /* read requested bytes */
+      for (i = 0; i < SD_DEFAULT_BLOCK_SIZE; i++) {
+        vAHI_SpiStartTransfer8(SPI_IDLE);
+        vAHI_SpiWaitBusy(); 
+        buffer[i + (n * SD_DEFAULT_BLOCK_SIZE)] = u8AHI_SpiReadTransfer8();
+      }
+
+      /* crc bytes (todo: check crc) */
+      vAHI_SpiStartTransfer8(SPI_IDLE);
+      vAHI_SpiWaitBusy();
+      vAHI_SpiStartTransfer8(SPI_IDLE);
+      vAHI_SpiWaitBusy();
+
+      RAISE_CS();
+
+      /* one pause cycle */
+      vAHI_SpiStartTransfer8(SPI_IDLE);
+      vAHI_SpiWaitBusy(); 
+      
+    } 
+    else 
+    {
+      RAISE_CS();
+      return RES_ERROR;
+    }
+  }
+  return RES_OK;
+}
+
+
+#if	_READONLY == 0
+/* write multiple sectors */
+DRESULT disk_write (BYTE drive, const BYTE* buffer, DWORD start_sector, BYTE sector_count)
+{
+  /* only drive 0 allowed */
+  if (drive)
+    return RES_PARERR;
+  
+  uint8_t temp = RES_OK;
+  uint16_t i, n;
+  for (n = 0; n < sector_count && temp == RES_OK; n++)
+  {
+    uint32_t argument = (start_sector + n) * address_mult;
+
+    LOWER_CS();
+
+    command(WRITE_BLOCK, argument);
+  
+    /* wait for response */
+    for (i = 0; i < SD_READ_RESPONSE_ATTEMPTS; i++)
+    {
+      vAHI_SpiStartTransfer8(SPI_IDLE);
+      vAHI_SpiWaitBusy(); 
+      temp = u8AHI_SpiReadTransfer8();
+      if (!temp)
+        break;
+    }
+    if (temp)
+    {
+      RAISE_CS();
+      return RES_NOTRDY;
+    }
+      
+    /* send some idles before start token (required?) */
+    for (i = 0; i < 8; i++)
+    {
+      vAHI_SpiStartTransfer8(SPI_IDLE);
+      vAHI_SpiWaitBusy();
+    }
+      
+    /* send start token */
+    vAHI_SpiStartTransfer8(START_BLOCK_TOKEN);
+    vAHI_SpiWaitBusy();
+     
+    /* send bytes */
+    for (i = 0; i < SD_DEFAULT_BLOCK_SIZE; i++)
+    {
+      vAHI_SpiWaitBusy();
+      vAHI_SpiStartTransfer8(buffer[i + (n * SD_DEFAULT_BLOCK_SIZE)]);
+    }
+    
+    /* wait for data response token */
+    for(i = 0; i < SD_TRANSACTION_ATTEMPTS; i++) 
+    {
+      vAHI_SpiStartTransfer8(SPI_IDLE);
+      vAHI_SpiWaitBusy();
+      temp = u8AHI_SpiReadTransfer8();
+      if ((temp & 0x11) == 1) 
+      {
+        /* Data response token received. */
+        temp = (temp >> 1) & 0x7;
+        if(temp == DATA_ACCEPTED) 
+        {
+          temp = RES_OK;
+          break;
+        } 
+        else 
+        {
+          temp = RES_ERROR;
+          break;
+        }
+      }
+    }      
+
+    /* wait until sd card is finished */
+    while (u8AHI_SpiReadTransfer8() != SPI_IDLE) 
+    {
+      vAHI_SpiStartTransfer8(SPI_IDLE);
+      vAHI_SpiWaitBusy();
+    }
+
+    RAISE_CS();
+  }
+  return temp;
+}
+#endif
+
+/* not completed? */
+DRESULT disk_ioctl (BYTE drive, BYTE command, void* buffer)
+{
+  if (command == CTRL_SYNC)
+    return RES_OK;
+  return RES_PARERR;
+}
+
+
+
+
diff --git a/cpu/jennic/dev/sd.h b/cpu/jennic/dev/sd.h
new file mode 100644
index 0000000..98fb36e
--- /dev/null
+++ b/cpu/jennic/dev/sd.h
@@ -0,0 +1,77 @@
+/*-----------------------------------------------------------------------
+/  Low level disk interface modlue include file
+/-----------------------------------------------------------------------*/
+
+#ifndef _DISKIO 
+
+#define _READONLY	0	/* 1: Remove write functions */
+#define _USE_IOCTL	1	/* 1: Use disk_ioctl fucntion */
+
+#include "ff.h"
+
+/* Status of Disk Functions */
+typedef BYTE	DSTATUS;
+
+/* Results of Disk Functions */
+typedef enum {
+	RES_OK = 0,		/* 0: Successful */
+	RES_ERROR,		/* 1: R/W Error */
+	RES_WRPRT,		/* 2: Write Protected */
+	RES_NOTRDY,		/* 3: Not Ready */
+	RES_PARERR		/* 4: Invalid Parameter */
+} DRESULT;
+
+
+/*---------------------------------------*/
+/* Prototypes for disk control functions */
+
+int assign_drives (int, int);
+DSTATUS disk_initialize (BYTE);
+DSTATUS disk_status (BYTE);
+DRESULT disk_read (BYTE, BYTE*, DWORD, BYTE);
+#if	_READONLY == 0
+DRESULT disk_write (BYTE, const BYTE*, DWORD, BYTE);
+#endif
+DRESULT disk_ioctl (BYTE, BYTE, void*);
+
+
+
+/* Disk Status Bits (DSTATUS) */
+
+#define STA_NOINIT		0x01	/* Drive not initialized */
+#define STA_NODISK		0x02	/* No medium in the drive */
+#define STA_PROTECT		0x04	/* Write protected */
+
+
+/* Command code for disk_ioctrl fucntion */
+
+/* Generic command (defined for FatFs) */
+#define CTRL_SYNC			0	/* Flush disk cache (for write functions) */
+#define GET_SECTOR_COUNT	1	/* Get media size (for only f_mkfs()) */
+#define GET_SECTOR_SIZE		2	/* Get sector size (for multiple sector size (_MAX_SS >= 1024)) */
+#define GET_BLOCK_SIZE		3	/* Get erase block size (for only f_mkfs()) */
+#define CTRL_ERASE_SECTOR	4	/* Force erased a block of sectors (for only _USE_ERASE) */
+
+/* Generic command */
+#define CTRL_POWER			5	/* Get/Set power status */
+#define CTRL_LOCK			6	/* Lock/Unlock media removal */
+#define CTRL_EJECT			7	/* Eject media */
+
+/* MMC/SDC specific ioctl command */
+#define MMC_GET_TYPE		10	/* Get card type */
+#define MMC_GET_CSD			11	/* Get CSD */
+#define MMC_GET_CID			12	/* Get CID */
+#define MMC_GET_OCR			13	/* Get OCR */
+#define MMC_GET_SDSTAT		14	/* Get SD status */
+
+/* ATA/CF specific ioctl command */
+#define ATA_GET_REV			20	/* Get F/W revision */
+#define ATA_GET_MODEL		21	/* Get model name */
+#define ATA_GET_SN			22	/* Get serial number */
+
+/* NAND specific ioctl command */
+#define NAND_FORMAT			30	/* Create physical format */
+
+
+#define _DISKIO
+#endif
diff --git a/cpu/jennic/dev/sd.h~ b/cpu/jennic/dev/sd.h~
new file mode 100644
index 0000000..8d20a76
--- /dev/null
+++ b/cpu/jennic/dev/sd.h~
@@ -0,0 +1,77 @@
+/*-----------------------------------------------------------------------
+/  Low level disk interface modlue include file
+/-----------------------------------------------------------------------*/
+
+#ifndef _DISKIO
+
+#define _READONLY	0	/* 1: Remove write functions */
+#define _USE_IOCTL	1	/* 1: Use disk_ioctl fucntion */
+
+#include "ff.h"
+
+/* Status of Disk Functions */
+typedef BYTE	DSTATUS;
+
+/* Results of Disk Functions */
+typedef enum {
+	RES_OK = 0,		/* 0: Successful */
+	RES_ERROR,		/* 1: R/W Error */
+	RES_WRPRT,		/* 2: Write Protected */
+	RES_NOTRDY,		/* 3: Not Ready */
+	RES_PARERR		/* 4: Invalid Parameter */
+} DRESULT;
+
+
+/*---------------------------------------*/
+/* Prototypes for disk control functions */
+
+int assign_drives (int, int);
+DSTATUS disk_initialize (BYTE);
+DSTATUS disk_status (BYTE);
+DRESULT disk_read (BYTE, BYTE*, DWORD, BYTE);
+#if	_READONLY == 0
+DRESULT disk_write (BYTE, const BYTE*, DWORD, BYTE);
+#endif
+DRESULT disk_ioctl (BYTE, BYTE, void*);
+
+
+
+/* Disk Status Bits (DSTATUS) */
+
+#define STA_NOINIT		0x01	/* Drive not initialized */
+#define STA_NODISK		0x02	/* No medium in the drive */
+#define STA_PROTECT		0x04	/* Write protected */
+
+
+/* Command code for disk_ioctrl fucntion */
+
+/* Generic command (defined for FatFs) */
+#define CTRL_SYNC			0	/* Flush disk cache (for write functions) */
+#define GET_SECTOR_COUNT	1	/* Get media size (for only f_mkfs()) */
+#define GET_SECTOR_SIZE		2	/* Get sector size (for multiple sector size (_MAX_SS >= 1024)) */
+#define GET_BLOCK_SIZE		3	/* Get erase block size (for only f_mkfs()) */
+#define CTRL_ERASE_SECTOR	4	/* Force erased a block of sectors (for only _USE_ERASE) */
+
+/* Generic command */
+#define CTRL_POWER			5	/* Get/Set power status */
+#define CTRL_LOCK			6	/* Lock/Unlock media removal */
+#define CTRL_EJECT			7	/* Eject media */
+
+/* MMC/SDC specific ioctl command */
+#define MMC_GET_TYPE		10	/* Get card type */
+#define MMC_GET_CSD			11	/* Get CSD */
+#define MMC_GET_CID			12	/* Get CID */
+#define MMC_GET_OCR			13	/* Get OCR */
+#define MMC_GET_SDSTAT		14	/* Get SD status */
+
+/* ATA/CF specific ioctl command */
+#define ATA_GET_REV			20	/* Get F/W revision */
+#define ATA_GET_MODEL		21	/* Get model name */
+#define ATA_GET_SN			22	/* Get serial number */
+
+/* NAND specific ioctl command */
+#define NAND_FORMAT			30	/* Create physical format */
+
+
+#define _DISKIO
+#endif
diff --git a/cpu/jennic/rtimer-arch.h b/cpu/jennic/rtimer-arch.h
index 1093875..47e131f 100644
--- a/cpu/jennic/rtimer-arch.h
+++ b/cpu/jennic/rtimer-arch.h
@@ -37,6 +37,5 @@
 #include "contiki-conf.h"
 
 #define RTIMER_ARCH_SECOND CLOCK_CONF_SECOND
-#define rtimer_arch_now() clock_time()
 
 #endif /* __RTIMER_ARCH_H__ */
diff --git a/platform/jndevkit/Makefile.jndevkit b/platform/jndevkit/Makefile.jndevkit
index eec8a11..77905f2 100644
--- a/platform/jndevkit/Makefile.jndevkit
+++ b/platform/jndevkit/Makefile.jndevkit
@@ -2,7 +2,8 @@ ifndef CONTIKI
   $(error CONTIKI not defined! You must specify where CONTIKI resides!)
 endif
 
-CONTIKI_TARGET_SOURCEFILES += ieee802.c contiki-main.c button-sensor.c\
+<<<<<<< HEAD
+CONTIKI_TARGET_SOURCEFILES += ieee802.c contiki-main.c sd.c ff.c cfs-fatfs.c button-sensor.c\
 														 	leds-arch.c leds.c sensors.c bootloader.c\
 															tsl2550-sensor.c
 CONTIKI_TARGET_DIRS += . dev net
@@ -13,4 +14,4 @@ TARGET_STARTFILES = ${addprefix $(OBJECTDIR)/,contiki-main.o}
 
 ### Define the CPU directory
 CONTIKI_CPU=$(CONTIKI)/cpu/jennic
-include $(CONTIKI)/cpu/jennic/Makefile.jn51xx
+include $(CONTIKI)/cpu/jennic/Makefile.jn51xx 
diff --git a/platform/jndevkit/Makefile.jndevkit~ b/platform/jndevkit/Makefile.jndevkit~
new file mode 100644
index 0000000..48c15d1
--- /dev/null
+++ b/platform/jndevkit/Makefile.jndevkit~
@@ -0,0 +1,20 @@
+ifndef CONTIKI
+  $(error CONTIKI not defined! You must specify where CONTIKI resides!)
+endif
+
+<<<<<<< HEAD
+CONTIKI_TARGET_SOURCEFILES += ieee802.c contiki-main.c sd.c ff.c cfs-fatfs.c\
+=======
+CONTIKI_TARGET_SOURCEFILES += ieee802.c contiki-main.c button-sensor.c\
+>>>>>>> phil/master
+														 	leds-arch.c leds.c sensors.c bootloader.c\
+															tsl2550-sensor.c
+CONTIKI_TARGET_DIRS += . dev net
+CONTIKI_SOURCEFILES += $(CONTIKI_TARGET_SOURCEFILES)
+TARGET_STARTFILES = ${addprefix $(OBJECTDIR)/,contiki-main.o}
+
+.SUFFIXES:
+
+### Define the CPU directory
+CONTIKI_CPU=$(CONTIKI)/cpu/jennic
+include $(CONTIKI)/cpu/jennic/Makefile.jn51xx 
diff --git a/platform/jndevkit/contiki-conf.h b/platform/jndevkit/contiki-conf.h
index 6bd613d..ca1e210 100644
--- a/platform/jndevkit/contiki-conf.h
+++ b/platform/jndevkit/contiki-conf.h
@@ -97,6 +97,11 @@ typedef unsigned short uip_stats_t;
 typedef unsigned long clock_time_t;
 #define CLOCK_CONF_SECOND 1000
 
+#define JENNIC_CONF_TIMESYNC 1
+
+typedef unsigned long long rtimer_clock_t;
+#define RTIMER_CLOCK_LT(a,b)     ((signed short)((a)-(b)) < 0)
+
 /* Not part of C99 but actually present */
 int strcasecmp(const char*, const char*);
 
diff --git a/platform/jnode/Makefile.jnode b/platform/jnode/Makefile.jnode
index 9ae766c..40ff5a1 100644
--- a/platform/jnode/Makefile.jnode
+++ b/platform/jnode/Makefile.jnode
@@ -2,7 +2,7 @@ ifndef CONTIKI
   $(error CONTIKI not defined! You must specify where CONTIKI resides!)
 endif
 
-CONTIKI_TARGET_SOURCEFILES += ieee802.c contiki-main.c pff.c sd.c\
+CONTIKI_TARGET_SOURCEFILES += ieee802.c contiki-main.c sd.c ff.c cfs-fatfs.c\
 														 	leds-arch.c leds.c sensors.c bootloader.c\
 															l3g4200d-sensor.c lsm303-sensor.c\
 															vcnl4000-sensor.c mpl115a-sensor.c\
diff --git a/platform/jnode/contiki-conf.h b/platform/jnode/contiki-conf.h
index ef78353..e17bded 100644
--- a/platform/jnode/contiki-conf.h
+++ b/platform/jnode/contiki-conf.h
@@ -101,6 +101,12 @@ typedef unsigned short uip_stats_t;
 typedef unsigned long clock_time_t;
 #define CLOCK_CONF_SECOND 1000
 
+#define LEDS_GREEN     0x01
+#define LEDS_INFRARED0 0x02
+#define LEDS_INFRARED1 0x04
+#define LEDS_INFRARED2 0x08
+#define LEDS_CONF_ALL  0x0f
+
 /* Not part of C99 but actually present */
 int strcasecmp(const char*, const char*);
 
diff --git a/platform/jnode/contiki-main.c b/platform/jnode/contiki-main.c
index 908fe47..4aff46d 100644
--- a/platform/jnode/contiki-main.c
+++ b/platform/jnode/contiki-main.c
@@ -3,7 +3,6 @@
 #include "bootloader.h"
 #include "gdb2.h"
 #include "jts.h"
-#include "pff.h"
 #include "net/ieee802.h"
 #include "dev/leds.h"
 #include "dev/lightlevel-sensor.h"
@@ -58,7 +57,6 @@ init_net(void)
 
 void AppColdStart(void)
 {
-  static FATFS fs;
   static uint8_t i=0;
 
   /* default startup, and make sure STBY pin of power reg is low,
@@ -69,25 +67,6 @@ void AppColdStart(void)
 
   /* initialize the sd-card first and wait for power supply to stabilize */
   clock_delay(CLOCK_SECOND/5);
-  switch(pf_mount(&fs)){
-  case FR_OK:
-    break;
-  case FR_NO_FILESYSTEM:
-    printf("pf_mount() failed: no filesystem\n");
-    break;
-  case FR_DISK_ERR:
-  case FR_NOT_READY:
-    printf("pf_mount() failed: no card found\n");
-    break;
-  default:
-    printf("pf_mount() failed\n");
-    break;
-  }
-
-  /* enable watchdog on JN5148, there is none on JN5139 */
-  #ifdef __BA2__
-    watchdog_start();
-  #endif
 
   /* start the rest */
   process_init();
diff --git a/platform/jnode/leds-arch.c b/platform/jnode/leds-arch.c
index f627d9f..1aaaad5 100644
--- a/platform/jnode/leds-arch.c
+++ b/platform/jnode/leds-arch.c
@@ -42,6 +42,10 @@ static uint8_t leds;
 void
 leds_arch_init(void)
 {
+  vAHI_DioSetDirection(0, E_AHI_DIO8_INT|
+                          E_AHI_DIO9_INT|
+                          E_AHI_DIO10_INT|
+                          E_AHI_DIO16_INT);
   leds_arch_set(0);
 }
 
@@ -57,11 +61,14 @@ leds_arch_set(unsigned char c)
 {
   leds = c;
 
-  if ((c&LEDS_ALL) || (c&LEDS_GREEN))
-    vAHI_DioSetDirection(0, E_AHI_DIO16_INT);
-  else if (c&LEDS_GREEN)
-    vAHI_DioSetDirection(0, E_AHI_DIO16_INT);
-  else
-    vAHI_DioSetDirection(E_AHI_DIO16_INT, 0);
+  uint32_t on = 0;
+  uint32_t off = 0;
+ 
+  if (leds & LEDS_GREEN) off |= E_AHI_DIO16_INT; else on |= E_AHI_DIO16_INT;
+  if (leds & LEDS_INFRARED0) off |= E_AHI_DIO8_INT; else on |= E_AHI_DIO8_INT;
+  if (leds & LEDS_INFRARED1) off |= E_AHI_DIO9_INT; else on |= E_AHI_DIO9_INT;
+  if (leds & LEDS_INFRARED2) off |= E_AHI_DIO10_INT; else on |= E_AHI_DIO10_INT;
+
+  vAHI_DioSetOutput(on, off);
 }
 
diff --git a/platform/jnode/pff.c b/platform/jnode/pff.c
deleted file mode 100644
index 11cdd10..0000000
--- a/platform/jnode/pff.c
+++ /dev/null
@@ -1,1112 +0,0 @@
-/*----------------------------------------------------------------------------/
-/  Petit FatFs - FAT file system module  R0.02a                (C)ChaN, 2010
-/-----------------------------------------------------------------------------/
-/ Petit FatFs module is an open source software to implement FAT file system to
-/ small embedded systems. This is a free software and is opened for education,
-/ research and commercial developments under license policy of following trems.
-/
-/  Copyright (C) 2010, ChaN, all right reserved.
-/
-/ * The Petit FatFs module is a free software and there is NO WARRANTY.
-/ * No restriction on use. You can use, modify and redistribute it for
-/   personal, non-profit or commercial use UNDER YOUR RESPONSIBILITY.
-/ * Redistributions of source code must retain the above copyright notice.
-/
-/-----------------------------------------------------------------------------/
-/ Jun 15,'09  R0.01a  First release. (Branched from FatFs R0.07b.)
-/
-/ Dec 14,'09  R0.02   Added multiple code page support.
-/                     Added write funciton.
-/                     Changed stream read mode interface.
-/ Dec 07,'10  R0.02a  Added some configuration options.
-/                     Fixed fails to open objects with DBCS character.
-/----------------------------------------------------------------------------*/
-
-#include "pff.h"        /* Petit FatFs configurations and declarations */
-#include "sd.h"
-
-/*--------------------------------------------------------------------------
-
-   Module Private Definitions
-
----------------------------------------------------------------------------*/
-
-
-#if _FS_FAT32
-#define LD_CLUST(dir)   (((DWORD)LD_WORD(dir+DIR_FstClusHI)<<16) | LD_WORD(dir+DIR_FstClusLO))
-#else
-#define LD_CLUST(dir)   LD_WORD(dir+DIR_FstClusLO)
-#endif
-
-
-/*--------------------------------------------------------*/
-/* DBCS code ranges and SBCS extend char conversion table */
-
-#if _CODE_PAGE == 932   /* Japanese Shift-JIS */
-#define _DF1S   0x81    /* DBC 1st byte range 1 start */
-#define _DF1E   0x9F    /* DBC 1st byte range 1 end */
-#define _DF2S   0xE0    /* DBC 1st byte range 2 start */
-#define _DF2E   0xFC    /* DBC 1st byte range 2 end */
-#define _DS1S   0x40    /* DBC 2nd byte range 1 start */
-#define _DS1E   0x7E    /* DBC 2nd byte range 1 end */
-#define _DS2S   0x80    /* DBC 2nd byte range 2 start */
-#define _DS2E   0xFC    /* DBC 2nd byte range 2 end */
-
-#elif _CODE_PAGE == 936 /* Simplified Chinese GBK */
-#define _DF1S   0x81
-#define _DF1E   0xFE
-#define _DS1S   0x40
-#define _DS1E   0x7E
-#define _DS2S   0x80
-#define _DS2E   0xFE
-
-#elif _CODE_PAGE == 949 /* Korean */
-#define _DF1S   0x81
-#define _DF1E   0xFE
-#define _DS1S   0x41
-#define _DS1E   0x5A
-#define _DS2S   0x61
-#define _DS2E   0x7A
-#define _DS3S   0x81
-#define _DS3E   0xFE
-
-#elif _CODE_PAGE == 950 /* Traditional Chinese Big5 */
-#define _DF1S   0x81
-#define _DF1E   0xFE
-#define _DS1S   0x40
-#define _DS1E   0x7E
-#define _DS2S   0xA1
-#define _DS2E   0xFE
-
-#elif _CODE_PAGE == 437 /* U.S. (OEM) */
-#define _DF1S   0
-#define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F,0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
-                0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
-                0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
-                0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
-
-#elif _CODE_PAGE == 720 /* Arabic (OEM) */
-#define _DF1S   0
-#define _EXCVT {0x80,0x81,0x45,0x41,0x84,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x49,0x49,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
-                0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
-                0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
-                0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
-
-#elif _CODE_PAGE == 737 /* Greek (OEM) */
-#define _DF1S   0
-#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x96,0x97,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87, \
-                0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
-                0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
-                0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xE7,0xE8,0xF1,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
-
-#elif _CODE_PAGE == 775 /* Baltic (OEM) */
-#define _DF1S   0
-#define _EXCVT {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0x95,0x96,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
-                0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
-                0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xA5,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
-                0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
-
-#elif _CODE_PAGE == 850 /* Multilingual Latin 1 (OEM) */
-#define _DF1S   0
-#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
-                0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
-                0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
-                0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
-
-#elif _CODE_PAGE == 852 /* Latin 2 (OEM) */
-#define _DF1S   0
-#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F,0x90,0x91,0x91,0xE2,0x99,0x95,0x95,0x97,0x97,0x99,0x9A,0x9B,0x9B,0x9D,0x9E,0x9F, \
-                0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBD,0xBF, \
-                0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD2,0xD5,0xD6,0xD7,0xB7,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
-                0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xEB,0xFC,0xFC,0xFE,0xFF}
-
-#elif _CODE_PAGE == 855 /* Cyrillic (OEM) */
-#define _DF1S   0
-#define _EXCVT {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F,0x91,0x91,0x93,0x93,0x95,0x95,0x97,0x97,0x99,0x99,0x9B,0x9B,0x9D,0x9D,0x9F,0x9F, \
-                0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB6,0xB6,0xB8,0xB8,0xB9,0xBA,0xBB,0xBC,0xBE,0xBE,0xBF, \
-                0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD3,0xD3,0xD5,0xD5,0xD7,0xD7,0xDD,0xD9,0xDA,0xDB,0xDC,0xDD,0xE0,0xDF, \
-                0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFD,0xFE,0xFF}
-
-#elif _CODE_PAGE == 857 /* Turkish (OEM) */
-#define _DF1S   0
-#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x98,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x98,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9E, \
-                0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
-                0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
-                0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0x59,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
-
-#elif _CODE_PAGE == 858 /* Multilingual Latin 1 + Euro (OEM) */
-#define _DF1S   0
-#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
-                0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
-                0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
-                0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
-
-#elif _CODE_PAGE == 862 /* Hebrew (OEM) */
-#define _DF1S   0
-#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
-                0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
-                0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
-                0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
-
-#elif _CODE_PAGE == 866 /* Russian (OEM) */
-#define _DF1S   0
-#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
-                0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
-                0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
-                0x90,0x91,0x92,0x93,0x9d,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
-
-#elif _CODE_PAGE == 874 /* Thai (OEM, Windows) */
-#define _DF1S   0
-#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
-                0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
-                0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
-                0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
-
-#elif _CODE_PAGE == 1250 /* Central Europe (Windows) */
-#define _DF1S   0
-#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
-                0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xA3,0xB4,0xB5,0xB6,0xB7,0xB8,0xA5,0xAA,0xBB,0xBC,0xBD,0xBC,0xAF, \
-                0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
-                0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
-
-#elif _CODE_PAGE == 1251 /* Cyrillic (Windows) */
-#define _DF1S   0
-#define _EXCVT {0x80,0x81,0x82,0x82,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x80,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
-                0xA0,0xA2,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB2,0xA5,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xA3,0xBD,0xBD,0xAF, \
-                0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
-                0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF}
-
-#elif _CODE_PAGE == 1252 /* Latin 1 (Windows) */
-#define _DF1S   0
-#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0xAd,0x9B,0x8C,0x9D,0xAE,0x9F, \
-                0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
-                0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
-                0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
-
-#elif _CODE_PAGE == 1253 /* Greek (Windows) */
-#define _DF1S   0
-#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
-                0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
-                0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xA2,0xB8,0xB9,0xBA, \
-                0xE0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xFB,0xBC,0xFD,0xBF,0xFF}
-
-#elif _CODE_PAGE == 1254 /* Turkish (Windows) */
-#define _DF1S   0
-#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x9D,0x9E,0x9F, \
-                0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
-                0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
-                0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
-
-#elif _CODE_PAGE == 1255 /* Hebrew (Windows) */
-#define _DF1S   0
-#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
-                0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
-                0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
-                0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
-
-#elif _CODE_PAGE == 1256 /* Arabic (Windows) */
-#define _DF1S   0
-#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x8C,0x9D,0x9E,0x9F, \
-                0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
-                0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
-                0x41,0xE1,0x41,0xE3,0xE4,0xE5,0xE6,0x43,0x45,0x45,0x45,0x45,0xEC,0xED,0x49,0x49,0xF0,0xF1,0xF2,0xF3,0x4F,0xF5,0xF6,0xF7,0xF8,0x55,0xFA,0x55,0x55,0xFD,0xFE,0xFF}
-
-#elif _CODE_PAGE == 1257 /* Baltic (Windows) */
-#define _DF1S   0
-#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
-                0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xBC,0xBD,0xBE,0xAF, \
-                0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
-                0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
-
-#elif _CODE_PAGE == 1258 /* Vietnam (OEM, Windows) */
-#define _DF1S   0
-#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0xAC,0x9D,0x9E,0x9F, \
-                0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
-                0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
-                0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xEC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xFE,0x9F}
-
-#elif _CODE_PAGE == 1   /* ASCII (for only non-LFN cfg) */
-#define _DF1S   0
-
-#else
-#error Unknown code page
-
-#endif
-
-
-
-/* Character code support macros */
-
-#define IsUpper(c)  (((c)>='A')&&((c)<='Z'))
-#define IsLower(c)  (((c)>='a')&&((c)<='z'))
-
-#if _DF1S       /* DBCS configuration */
-
-#ifdef _DF2S    /* Two 1st byte areas */
-#define IsDBCS1(c)  (((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E) || ((BYTE)(c) >= _DF2S && (BYTE)(c) <= _DF2E))
-#else           /* One 1st byte area */
-#define IsDBCS1(c)  ((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E)
-#endif
-
-#ifdef _DS3S    /* Three 2nd byte areas */
-#define IsDBCS2(c)  (((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E) || ((BYTE)(c) >= _DS3S && (BYTE)(c) <= _DS3E))
-#else           /* Two 2nd byte areas */
-#define IsDBCS2(c)  (((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E))
-#endif
-
-#else           /* SBCS configuration */
-
-#define IsDBCS1(c)  0
-#define IsDBCS2(c)  0
-
-#endif /* _DF1S */
-
-
-/* FatFs refers the members in the FAT structures with byte offset instead
-/ of structure member because there are incompatibility of the packing option
-/ between various compilers. */
-
-#define BS_jmpBoot          0
-#define BS_OEMName          3
-#define BPB_BytsPerSec      11
-#define BPB_SecPerClus      13
-#define BPB_RsvdSecCnt      14
-#define BPB_NumFATs         16
-#define BPB_RootEntCnt      17
-#define BPB_TotSec16        19
-#define BPB_Media           21
-#define BPB_FATSz16         22
-#define BPB_SecPerTrk       24
-#define BPB_NumHeads        26
-#define BPB_HiddSec         28
-#define BPB_TotSec32        32
-#define BS_55AA             510
-
-#define BS_DrvNum           36
-#define BS_BootSig          38
-#define BS_VolID            39
-#define BS_VolLab           43
-#define BS_FilSysType       54
-
-#define BPB_FATSz32         36
-#define BPB_ExtFlags        40
-#define BPB_FSVer           42
-#define BPB_RootClus        44
-#define BPB_FSInfo          48
-#define BPB_BkBootSec       50
-#define BS_DrvNum32         64
-#define BS_BootSig32        66
-#define BS_VolID32          67
-#define BS_VolLab32         71
-#define BS_FilSysType32     82
-
-#define MBR_Table           446
-
-#define DIR_Name            0
-#define DIR_Attr            11
-#define DIR_NTres           12
-#define DIR_CrtTime         14
-#define DIR_CrtDate         16
-#define DIR_FstClusHI       20
-#define DIR_WrtTime         22
-#define DIR_WrtDate         24
-#define DIR_FstClusLO       26
-#define DIR_FileSize        28
-
-
-
-/*--------------------------------------------------------------------------
-
-   Private Functions
-
----------------------------------------------------------------------------*/
-
-
-static
-FATFS *FatFs;   /* Pointer to the file system object (logical drive) */
-
-
-/* Fill memory */
-static
-void mem_set (void* dst, int val, int cnt) {
-    char *d = (char*)dst;
-    while (cnt--) *d++ = (char)val;
-}
-
-/* Compare memory to memory */
-static
-int mem_cmp (const void* dst, const void* src, int cnt) {
-    const char *d = (const char *)dst, *s = (const char *)src;
-    int r = 0;
-    while (cnt-- && (r = *d++ - *s++) == 0) ;
-    return r;
-}
-
-
-
-/*-----------------------------------------------------------------------*/
-/* FAT access - Read value of a FAT entry                                */
-/*-----------------------------------------------------------------------*/
-
-static
-CLUST get_fat ( /* 1:IO error, Else:Cluster status */
-    CLUST clst  /* Cluster# to get the link information */
-)
-{
-    WORD wc, bc, ofs;
-    BYTE buf[4];
-    FATFS *fs = FatFs;
-
-
-    if (clst < 2 || clst >= fs->n_fatent)   /* Range check */
-        return 1;
-
-    switch (fs->fs_type) {
-#if _FS_FAT12
-    case FS_FAT12 :
-        bc = (WORD)clst; bc += bc / 2;
-        ofs = bc % 512; bc /= 512;
-        if (ofs != 511) {
-            if (disk_readp(buf, fs->fatbase + bc, ofs, 2)) break;
-        } else {
-            if (disk_readp(buf, fs->fatbase + bc, 511, 1)) break;
-            if (disk_readp(buf+1, fs->fatbase + bc + 1, 0, 1)) break;
-        }
-        wc = LD_WORD(buf);
-        return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
-#endif
-    case FS_FAT16 :
-        if (disk_readp(buf, fs->fatbase + clst / 256, (WORD)(((WORD)clst % 256) * 2), 2)) break;
-        return LD_WORD(buf);
-#if _FS_FAT32
-    case FS_FAT32 :
-        if (disk_readp(buf, fs->fatbase + clst / 128, (WORD)(((WORD)clst % 128) * 4), 4)) break;
-        return LD_DWORD(buf) & 0x0FFFFFFF;
-#endif
-    }
-
-    return 1;   /* An error occured at the disk I/O layer */
-}
-
-
-
-
-/*-----------------------------------------------------------------------*/
-/* Get sector# from cluster#                                             */
-/*-----------------------------------------------------------------------*/
-
-static
-DWORD clust2sect (  /* !=0: Sector number, 0: Failed - invalid cluster# */
-    CLUST clst      /* Cluster# to be converted */
-)
-{
-    FATFS *fs = FatFs;
-
-
-    clst -= 2;
-    if (clst >= (fs->n_fatent - 2)) return 0;       /* Invalid cluster# */
-    return (DWORD)clst * fs->csize + fs->database;
-}
-
-
-
-
-/*-----------------------------------------------------------------------*/
-/* Directory handling - Rewind directory index                           */
-/*-----------------------------------------------------------------------*/
-
-static
-FRESULT dir_rewind (
-    DIR *dj         /* Pointer to directory object */
-)
-{
-    CLUST clst;
-    FATFS *fs = FatFs;
-
-
-    dj->index = 0;
-    clst = dj->sclust;
-    if (clst == 1 || clst >= fs->n_fatent)  /* Check start cluster range */
-        return FR_DISK_ERR;
-    if (_FS_FAT32 && !clst && fs->fs_type == FS_FAT32)  /* Replace cluster# 0 with root cluster# if in FAT32 */
-        clst = (CLUST)fs->dirbase;
-    dj->clust = clst;                       /* Current cluster */
-    dj->sect = clst ? clust2sect(clst) : fs->dirbase;   /* Current sector */
-
-    return FR_OK;   /* Seek succeeded */
-}
-
-
-
-
-/*-----------------------------------------------------------------------*/
-/* Directory handling - Move directory index next                        */
-/*-----------------------------------------------------------------------*/
-
-static
-FRESULT dir_next (  /* FR_OK:Succeeded, FR_NO_FILE:End of table */
-    DIR *dj         /* Pointer to directory object */
-)
-{
-    CLUST clst;
-    WORD i;
-    FATFS *fs = FatFs;
-
-
-    i = dj->index + 1;
-    if (!i || !dj->sect)    /* Report EOT when index has reached 65535 */
-        return FR_NO_FILE;
-
-    if (!(i % 16)) {        /* Sector changed? */
-        dj->sect++;         /* Next sector */
-
-        if (dj->clust == 0) {   /* Static table */
-            if (i >= fs->n_rootdir) /* Report EOT when end of table */
-                return FR_NO_FILE;
-        }
-        else {                  /* Dynamic table */
-            if (((i / 16) & (fs->csize-1)) == 0) {  /* Cluster changed? */
-                clst = get_fat(dj->clust);      /* Get next cluster */
-                if (clst <= 1) return FR_DISK_ERR;
-                if (clst >= fs->n_fatent)       /* When it reached end of dynamic table */
-                    return FR_NO_FILE;          /* Report EOT */
-                dj->clust = clst;               /* Initialize data for new cluster */
-                dj->sect = clust2sect(clst);
-            }
-        }
-    }
-
-    dj->index = i;
-
-    return FR_OK;
-}
-
-
-
-
-/*-----------------------------------------------------------------------*/
-/* Directory handling - Find an object in the directory                  */
-/*-----------------------------------------------------------------------*/
-
-static
-FRESULT dir_find (
-    DIR *dj,        /* Pointer to the directory object linked to the file name */
-    BYTE *dir       /* 32-byte working buffer */
-)
-{
-    FRESULT res;
-    BYTE c;
-
-
-    res = dir_rewind(dj);           /* Rewind directory object */
-    if (res != FR_OK) return res;
-
-    do {
-        res = disk_readp(dir, dj->sect, (WORD)((dj->index % 16) * 32), 32)  /* Read an entry */
-            ? FR_DISK_ERR : FR_OK;
-        if (res != FR_OK) break;
-        c = dir[DIR_Name];  /* First character */
-        if (c == 0) { res = FR_NO_FILE; break; }    /* Reached to end of table */
-        if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
-            break;
-        res = dir_next(dj);                 /* Next entry */
-    } while (res == FR_OK);
-
-    return res;
-}
-
-
-
-
-/*-----------------------------------------------------------------------*/
-/* Read an object from the directory                                     */
-/*-----------------------------------------------------------------------*/
-#if _USE_DIR
-static
-FRESULT dir_read (
-    DIR *dj,        /* Pointer to the directory object to store read object name */
-    BYTE *dir       /* 32-byte working buffer */
-)
-{
-    FRESULT res;
-    BYTE a, c;
-
-
-    res = FR_NO_FILE;
-    while (dj->sect) {
-        res = disk_readp(dir, dj->sect, (WORD)((dj->index % 16) * 32), 32)  /* Read an entry */
-            ? FR_DISK_ERR : FR_OK;
-        if (res != FR_OK) break;
-        c = dir[DIR_Name];
-        if (c == 0) { res = FR_NO_FILE; break; }    /* Reached to end of table */
-        a = dir[DIR_Attr] & AM_MASK;
-        if (c != 0xE5 && c != '.' && !(a & AM_VOL)) /* Is it a valid entry? */
-            break;
-        res = dir_next(dj);         /* Next entry */
-        if (res != FR_OK) break;
-    }
-
-    if (res != FR_OK) dj->sect = 0;
-
-    return res;
-}
-#endif
-
-
-
-/*-----------------------------------------------------------------------*/
-/* Pick a segment and create the object name in directory form           */
-/*-----------------------------------------------------------------------*/
-
-#ifdef _EXCVT
-    static const BYTE cvt[] = _EXCVT;
-#endif
-
-static
-FRESULT create_name (
-    DIR *dj,            /* Pointer to the directory object */
-    const char **path   /* Pointer to pointer to the segment in the path string */
-)
-{
-    BYTE c, d, ni, si, i, *sfn;
-    const char *p;
-
-    /* Create file name in directory form */
-    sfn = dj->fn;
-    mem_set(sfn, ' ', 11);
-    si = i = 0; ni = 8;
-    p = *path;
-    for (;;) {
-        c = p[si++];
-        if (c <= ' ' || c == '/') break;    /* Break on end of segment */
-        if (c == '.' || i >= ni) {
-            if (ni != 8 || c != '.') break;
-            i = 8; ni = 11;
-            continue;
-        }
-#ifdef _EXCVT
-        if (c >= 0x80)                  /* To upper extended char (SBCS) */
-            c = cvt[c - 0x80];
-#endif
-        if (IsDBCS1(c) && i < ni - 1) { /* DBC 1st byte? */
-            d = p[si++];                /* Get 2nd byte */
-            sfn[i++] = c;
-            sfn[i++] = d;
-        } else {                        /* Single byte code */
-            if (IsLower(c)) c -= 0x20;  /* toupper */
-            sfn[i++] = c;
-        }
-    }
-    *path = &p[si];                     /* Rerurn pointer to the next segment */
-
-    sfn[11] = (c <= ' ') ? 1 : 0;       /* Set last segment flag if end of path */
-
-    return FR_OK;
-}
-
-
-
-
-/*-----------------------------------------------------------------------*/
-/* Get file information from directory entry                             */
-/*-----------------------------------------------------------------------*/
-#if _USE_DIR
-static
-void get_fileinfo (     /* No return code */
-    DIR *dj,            /* Pointer to the directory object */
-    BYTE *dir,          /* 32-byte working buffer */
-    FILINFO *fno        /* Pointer to store the file information */
-)
-{
-    BYTE i, c;
-    char *p;
-
-
-    p = fno->fname;
-    if (dj->sect) {
-        for (i = 0; i < 8; i++) {   /* Copy file name body */
-            c = dir[i];
-            if (c == ' ') break;
-            if (c == 0x05) c = 0xE5;
-            *p++ = c;
-        }
-        if (dir[8] != ' ') {        /* Copy file name extension */
-            *p++ = '.';
-            for (i = 8; i < 11; i++) {
-                c = dir[i];
-                if (c == ' ') break;
-                *p++ = c;
-            }
-        }
-        fno->fattrib = dir[DIR_Attr];               /* Attribute */
-        fno->fsize = LD_DWORD(dir+DIR_FileSize);    /* Size */
-        fno->fdate = LD_WORD(dir+DIR_WrtDate);      /* Date */
-        fno->ftime = LD_WORD(dir+DIR_WrtTime);      /* Time */
-    }
-    *p = 0;
-}
-#endif /* _USE_DIR */
-
-
-
-/*-----------------------------------------------------------------------*/
-/* Follow a file path                                                    */
-/*-----------------------------------------------------------------------*/
-
-static
-FRESULT follow_path (   /* FR_OK(0): successful, !=0: error code */
-    DIR *dj,            /* Directory object to return last directory and found object */
-    BYTE *dir,          /* 32-byte working buffer */
-    const char *path    /* Full-path string to find a file or directory */
-)
-{
-    FRESULT res;
-
-
-    while (*path == ' ') path++;        /* Skip leading spaces */
-    if (*path == '/') path++;           /* Strip heading separator */
-    dj->sclust = 0;                     /* Set start directory (always root dir) */
-
-    if ((BYTE)*path <= ' ') {           /* Null path means the root directory */
-        res = dir_rewind(dj);
-        dir[0] = 0;
-
-    } else {                            /* Follow path */
-        for (;;) {
-            res = create_name(dj, &path);   /* Get a segment */
-            if (res != FR_OK) break;
-            res = dir_find(dj, dir);        /* Find it */
-            if (res != FR_OK) {             /* Could not find the object */
-                if (res == FR_NO_FILE && !*(dj->fn+11))
-                    res = FR_NO_PATH;
-                break;
-            }
-            if (*(dj->fn+11)) break;        /* Last segment match. Function completed. */
-            if (!(dir[DIR_Attr] & AM_DIR)) { /* Cannot follow because it is a file */
-                res = FR_NO_PATH; break;
-            }
-            dj->sclust = LD_CLUST(dir);
-        }
-    }
-
-    return res;
-}
-
-
-
-
-/*-----------------------------------------------------------------------*/
-/* Check a sector if it is an FAT boot record                            */
-/*-----------------------------------------------------------------------*/
-
-static
-BYTE check_fs ( /* 0:The FAT boot record, 1:Valid boot record but not an FAT, 2:Not a boot record, 3:Error */
-    BYTE *buf,  /* Working buffer */
-    DWORD sect  /* Sector# (lba) to check if it is an FAT boot record or not */
-)
-{
-    if (disk_readp(buf, sect, 510, 2))      /* Read the boot sector */
-    return 3;
-
-    if (LD_WORD(buf) != 0xAA55)             /* Check record signature */
-        return 2;
-
-    if (!disk_readp(buf, sect, BS_FilSysType, 2) && LD_WORD(buf) == 0x4146) /* Check FAT12/16 */
-        return 0;
-    if (_FS_FAT32 && !disk_readp(buf, sect, BS_FilSysType32, 2) && LD_WORD(buf) == 0x4146)  /* Check FAT32 */
-        return 0;
-    return 1;
-}
-
-
-/*--------------------------------------------------------------------------
-
-   Public Functions
-
---------------------------------------------------------------------------*/
-
-
-
-/*-----------------------------------------------------------------------*/
-/* Mount/Unmount a Locical Drive                                         */
-/*-----------------------------------------------------------------------*/
-
-FRESULT pf_mount (
-    FATFS *fs       /* Pointer to new file system object (NULL: Unmount) */
-)
-{
-    BYTE fmt, buf[36],i;
-    DWORD bsect, fsize, tsect, mclst;
-
-    FatFs = 0;
-    if (!fs) return FR_OK;              /* Unregister fs object */
-
-    if (disk_initialize() & STA_NOINIT) /* Check if the drive is ready or not */
-        return FR_NOT_READY;
-
-    /* Search FAT partition on the drive */
-    bsect = 0;
-    fmt = check_fs(buf, bsect);         /* Check sector 0 as an SFD format */
-    if (fmt == 1) {                     /* Not an FAT boot record, it may be FDISK format */
-        /* Check a partition listed in top of the partition table */
-        if (disk_readp(buf, bsect, MBR_Table, 16)) {    /* 1st partition entry */
-            fmt = 3;
-        } else {
-            if (buf[4]) {                   /* Is the partition existing? */
-                bsect = LD_DWORD(&buf[8]);  /* Partition offset in LBA */
-                fmt = check_fs(buf, bsect); /* Check the partition */
-            }
-        }
-    }
-    if (fmt == 3) return FR_DISK_ERR;
-    if (fmt) return FR_NO_FILESYSTEM;   /* No valid FAT patition is found */
-
-    /* Initialize the file system object */
-    if (disk_readp(buf, bsect, 13, sizeof(buf))) return FR_DISK_ERR;
-
-    fsize = LD_WORD(buf+BPB_FATSz16-13);                /* Number of sectors per FAT */
-    if (!fsize) fsize = LD_DWORD(buf+BPB_FATSz32-13);
-
-    fsize *= buf[BPB_NumFATs-13];                       /* Number of sectors in FAT area */
-    fs->fatbase = bsect + LD_WORD(buf+BPB_RsvdSecCnt-13); /* FAT start sector (lba) */
-    fs->csize = buf[BPB_SecPerClus-13];                 /* Number of sectors per cluster */
-    fs->n_rootdir = LD_WORD(buf+BPB_RootEntCnt-13);     /* Nmuber of root directory entries */
-    tsect = LD_WORD(buf+BPB_TotSec16-13);               /* Number of sectors on the file system */
-    if (!tsect) tsect = LD_DWORD(buf+BPB_TotSec32-13);
-    mclst = (tsect                      /* Last cluster# + 1 */
-        - LD_WORD(buf+BPB_RsvdSecCnt-13) - fsize - fs->n_rootdir / 16
-        ) / fs->csize + 2;
-    fs->n_fatent = (CLUST)mclst;
-
-    fmt = FS_FAT16;                         /* Determine the FAT sub type */
-    if (mclst < 0xFF7)                      /* Number of clusters < 0xFF5 */
-#if _FS_FAT12
-        fmt = FS_FAT12;
-#else
-        return FR_NO_FILESYSTEM;
-#endif
-    if (mclst >= 0xFFF7)                    /* Number of clusters >= 0xFFF5 */
-#if _FS_FAT32
-        fmt = FS_FAT32;
-#else
-        return FR_NO_FILESYSTEM;
-#endif
-
-    fs->fs_type = fmt;      /* FAT sub-type */
-    if (_FS_FAT32 && fmt == FS_FAT32)
-        fs->dirbase = LD_DWORD(buf+(BPB_RootClus-13));  /* Root directory start cluster */
-    else
-        fs->dirbase = fs->fatbase + fsize;              /* Root directory start sector (lba) */
-    fs->database = fs->fatbase + fsize + fs->n_rootdir / 16;    /* Data start sector (lba) */
-
-    fs->flag = 0;
-    FatFs = fs;
-
-    return FR_OK;
-}
-
-
-
-
-/*-----------------------------------------------------------------------*/
-/* Open or Create a File                                                 */
-/*-----------------------------------------------------------------------*/
-
-FRESULT pf_open (
-    const char *path    /* Pointer to the file name */
-)
-{
-    FRESULT res;
-    DIR dj;
-    BYTE sp[12], dir[32];
-    FATFS *fs = FatFs;
-
-    if (!fs)                        /* Check file system */
-        return FR_NOT_ENABLED;
-
-    fs->flag = 0;
-    dj.fn = sp;
-    res = follow_path(&dj, dir, path);  /* Follow the file path */
-    if (res != FR_OK) return res;       /* Follow failed */
-    if (!dir[0] || (dir[DIR_Attr] & AM_DIR))    /* It is a directory */
-        return FR_NO_FILE;
-
-    fs->org_clust = LD_CLUST(dir);          /* File start cluster */
-    fs->fsize = LD_DWORD(dir+DIR_FileSize); /* File size */
-    fs->fptr = 0;                       /* File pointer */
-    fs->flag = FA_OPENED;
-
-    return FR_OK;
-}
-
-
-
-
-/*-----------------------------------------------------------------------*/
-/* Read File                                                             */
-/*-----------------------------------------------------------------------*/
-#if _USE_READ
-
-FRESULT pf_read (
-    void* buff,     /* Pointer to the read buffer (NULL:Forward data to the stream)*/
-    WORD btr,       /* Number of bytes to read */
-    WORD* br        /* Pointer to number of bytes read */
-)
-{
-    DRESULT dr;
-    CLUST clst;
-    DWORD sect, remain;
-    WORD rcnt;
-    BYTE cs, *rbuff = buff;
-    FATFS *fs = FatFs;
-
-
-    *br = 0;
-    if (!fs) return FR_NOT_ENABLED;     /* Check file system */
-    if (!(fs->flag & FA_OPENED))        /* Check if opened */
-        return FR_NOT_OPENED;
-
-    remain = fs->fsize - fs->fptr;
-    if (btr > remain) btr = (WORD)remain;           /* Truncate btr by remaining bytes */
-
-    while (btr) {                                   /* Repeat until all data transferred */
-        if ((fs->fptr % 512) == 0) {                /* On the sector boundary? */
-            cs = (BYTE)(fs->fptr / 512 & (fs->csize - 1));  /* Sector offset in the cluster */
-            if (!cs) {                              /* On the cluster boundary? */
-                clst = (fs->fptr == 0) ?            /* On the top of the file? */
-                    fs->org_clust : get_fat(fs->curr_clust);
-                if (clst <= 1) goto fr_abort;
-                fs->curr_clust = clst;              /* Update current cluster */
-            }
-            sect = clust2sect(fs->curr_clust);      /* Get current sector */
-            if (!sect) goto fr_abort;
-            fs->dsect = sect + cs;
-        }
-        rcnt = (WORD)(512 - (fs->fptr % 512));      /* Get partial sector data from sector buffer */
-        if (rcnt > btr) rcnt = btr;
-        dr = disk_readp(!buff ? 0 : rbuff, fs->dsect, (WORD)(fs->fptr % 512), rcnt);
-        if (dr) goto fr_abort;
-        fs->fptr += rcnt; rbuff += rcnt;            /* Update pointers and counters */
-        btr -= rcnt; *br += rcnt;
-    }
-
-    return FR_OK;
-
-fr_abort:
-    fs->flag = 0;
-    return FR_DISK_ERR;
-}
-#endif
-
-
-
-/*-----------------------------------------------------------------------*/
-/* Write File                                                            */
-/*-----------------------------------------------------------------------*/
-#if _USE_WRITE
-
-FRESULT pf_write (
-    const void* buff,   /* Pointer to the data to be written */
-    WORD btw,           /* Number of bytes to write (0:Finalize the current write operation) */
-    WORD* bw            /* Pointer to number of bytes written */
-)
-{
-    CLUST clst;
-    DWORD sect, remain;
-    const BYTE *p = buff;
-    BYTE cs;
-    WORD wcnt;
-    FATFS *fs = FatFs;
-
-    *bw = 0;
-    if (!fs) return FR_NOT_ENABLED;     /* Check file system */
-    if (!(fs->flag & FA_OPENED))        /* Check if opened */
-        return FR_NOT_OPENED;
-
-    if (!btw) {     /* Finalize request */
-        if ((fs->flag & FA__WIP) && disk_writep(0, 0)) goto fw_abort;
-        fs->flag &= ~FA__WIP;
-        return FR_OK;
-    } else {        /* Write data request */
-        if (!(fs->flag & FA__WIP))      /* Round-down fptr to the sector boundary */
-            fs->fptr &= 0xFFFFFE00;
-    }
-    remain = fs->fsize - fs->fptr;
-
-    if (btw > remain) btw = (WORD)remain;           /* Truncate btw by remaining bytes */
-
-    if (remain==0)
-      return FR_FULL;
-
-    while (btw) {                                   /* Repeat until all data transferred */
-        if (((WORD)fs->fptr % 512) == 0) {          /* On the sector boundary? */
-            cs = (BYTE)(fs->fptr / 512 & (fs->csize - 1));  /* Sector offset in the cluster */
-            if (!cs) {                              /* On the cluster boundary? */
-                clst = (fs->fptr == 0) ?            /* On the top of the file? */
-                    fs->org_clust : get_fat(fs->curr_clust);
-                if (clst <= 1) goto fw_abort;
-                fs->curr_clust = clst;              /* Update current cluster */
-            }
-            sect = clust2sect(fs->curr_clust);      /* Get current sector */
-            if (!sect) goto fw_abort;
-            fs->dsect = sect + cs;
-            if (disk_writep(0, fs->dsect)) goto fw_abort;   /* Initiate a sector write operation */
-            fs->flag |= FA__WIP;
-        }
-        wcnt = 512 - ((WORD)fs->fptr % 512);        /* Number of bytes to write to the sector */
-        if (wcnt > btw) wcnt = btw;
-        if (disk_writep(p, wcnt)) goto fw_abort;    /* Send data to the sector */
-        fs->fptr += wcnt; p += wcnt;                /* Update pointers and counters */
-        btw -= wcnt; *bw += wcnt;
-        if (((WORD)fs->fptr % 512) == 0) {
-            if (disk_writep(0, 0)) goto fw_abort;   /* Finalize the currtent secter write operation */
-            fs->flag &= ~FA__WIP;
-        }
-    }
-
-    return FR_OK;
-
-fw_abort:
-    fs->flag = 0;
-    return FR_DISK_ERR;
-}
-#endif
-
-
-
-/*-----------------------------------------------------------------------*/
-/* Seek File R/W Pointer                                                 */
-/*-----------------------------------------------------------------------*/
-#if _USE_LSEEK
-
-FRESULT pf_lseek (
-    DWORD ofs       /* File pointer from top of file */
-)
-{
-    CLUST clst;
-    DWORD bcs, sect, ifptr;
-    FATFS *fs = FatFs;
-
-
-    if (!fs) return FR_NOT_ENABLED;     /* Check file system */
-    if (!(fs->flag & FA_OPENED))        /* Check if opened */
-            return FR_NOT_OPENED;
-
-    if (ofs > fs->fsize) ofs = fs->fsize;   /* Clip offset with the file size */
-    ifptr = fs->fptr;
-    fs->fptr = 0;
-    if (ofs > 0) {
-        bcs = (DWORD)fs->csize * 512;   /* Cluster size (byte) */
-        if (ifptr > 0 &&
-            (ofs - 1) / bcs >= (ifptr - 1) / bcs) { /* When seek to same or following cluster, */
-            fs->fptr = (ifptr - 1) & ~(bcs - 1);    /* start from the current cluster */
-            ofs -= fs->fptr;
-            clst = fs->curr_clust;
-        } else {                            /* When seek to back cluster, */
-            clst = fs->org_clust;           /* start from the first cluster */
-            fs->curr_clust = clst;
-        }
-        while (ofs > bcs) {             /* Cluster following loop */
-            clst = get_fat(clst);       /* Follow cluster chain */
-            if (clst <= 1 || clst >= fs->n_fatent) goto fe_abort;
-            fs->curr_clust = clst;
-            fs->fptr += bcs;
-            ofs -= bcs;
-        }
-        fs->fptr += ofs;
-        sect = clust2sect(clst);        /* Current sector */
-        if (!sect) goto fe_abort;
-        fs->dsect = sect + (fs->fptr / 512 & (fs->csize - 1));
-    }
-
-    return FR_OK;
-
-fe_abort:
-    fs->flag = 0;
-    return FR_DISK_ERR;
-}
-#endif
-
-
-
-/*-----------------------------------------------------------------------*/
-/* Create a Directroy Object                                             */
-/*-----------------------------------------------------------------------*/
-#if _USE_DIR
-
-FRESULT pf_opendir (
-    DIR *dj,            /* Pointer to directory object to create */
-    const char *path    /* Pointer to the directory path */
-)
-{
-    FRESULT res;
-    BYTE sp[12], dir[32];
-    FATFS *fs = FatFs;
-
-
-    if (!fs) {              /* Check file system */
-        res = FR_NOT_ENABLED;
-    } else {
-        dj->fn = sp;
-        res = follow_path(dj, dir, path);       /* Follow the path to the directory */
-        if (res == FR_OK) {                     /* Follow completed */
-            if (dir[0]) {                       /* It is not the root dir */
-                if (dir[DIR_Attr] & AM_DIR)     /* The object is a directory */
-                    dj->sclust = LD_CLUST(dir);
-                else                            /* The object is not a directory */
-                    res = FR_NO_PATH;
-            }
-            if (res == FR_OK)
-                res = dir_rewind(dj);           /* Rewind dir */
-        }
-        if (res == FR_NO_FILE) res = FR_NO_PATH;
-    }
-
-    return res;
-}
-
-
-
-
-/*-----------------------------------------------------------------------*/
-/* Read Directory Entry in Sequense                                      */
-/*-----------------------------------------------------------------------*/
-
-FRESULT pf_readdir (
-    DIR *dj,            /* Pointer to the open directory object */
-    FILINFO *fno        /* Pointer to file information to return */
-)
-{
-    FRESULT res;
-    BYTE sp[12], dir[32];
-    FATFS *fs = FatFs;
-
-
-    if (!fs) {              /* Check file system */
-        res = FR_NOT_ENABLED;
-    } else {
-        dj->fn = sp;
-        if (!fno) {
-            res = dir_rewind(dj);
-        } else {
-            res = dir_read(dj, dir);
-            if (res == FR_NO_FILE) {
-                dj->sect = 0;
-                res = FR_OK;
-            }
-            if (res == FR_OK) {             /* A valid entry is found */
-                get_fileinfo(dj, dir, fno); /* Get the object information */
-                res = dir_next(dj);         /* Increment index for next */
-                if (res == FR_NO_FILE) {
-                    dj->sect = 0;
-                    res = FR_OK;
-                }
-            }
-        }
-    }
-
-    return res;
-}
-
-#endif /* _USE_DIR */
-
diff --git a/platform/jnode/pff.h b/platform/jnode/pff.h
deleted file mode 100644
index 5070704..0000000
--- a/platform/jnode/pff.h
+++ /dev/null
@@ -1,217 +0,0 @@
-/*---------------------------------------------------------------------------/
-/  Petit FatFs - FAT file system module include file  R0.02a   (C)ChaN, 2010
-/----------------------------------------------------------------------------/
-/ Petit FatFs module is an open source software to implement FAT file system to
-/ small embedded systems. This is a free software and is opened for education,
-/ research and commercial developments under license policy of following trems.
-/
-/  Copyright (C) 2010, ChaN, all right reserved.
-/
-/ * The Petit FatFs module is a free software and there is NO WARRANTY.
-/ * No restriction on use. You can use, modify and redistribute it for
-/   personal, non-profit or commercial use UNDER YOUR RESPONSIBILITY.
-/ * Redistributions of source code must retain the above copyright notice.
-/
-/----------------------------------------------------------------------------*/
-
-#ifndef _FATFS
-#define _FATFS
-
-#include "contiki.h"
-
-/* These types must be 16-bit, 32-bit or larger integer */
-typedef int				INT;
-typedef unsigned int	UINT;
-
-/* These types must be 8-bit integer */
-typedef char			CHAR;
-typedef unsigned char	UCHAR;
-typedef unsigned char	BYTE;
-
-/* These types must be 16-bit integer */
-typedef short			SHORT;
-typedef unsigned short	USHORT;
-typedef unsigned short	WORD;
-typedef unsigned short	WCHAR;
-
-/* These types must be 32-bit integer */
-typedef long			LONG;
-typedef unsigned long	ULONG;
-typedef unsigned long	DWORD;
-
-
-
-/*---------------------------------------------------------------------------/
-/ Petit FatFs Configuration Options
-/
-/ CAUTION! Do not forget to make clean the project after any changes to
-/ the configuration options.
-/
-/----------------------------------------------------------------------------*/
-
-#define	_USE_READ	1	/* 1:Enable pf_read() */
-
-#define	_USE_DIR	0	/* 1:Enable pf_opendir() and pf_readdir() */
-
-#define	_USE_LSEEK	0	/* 1:Enable pf_lseek() */
-
-#define	_USE_WRITE	1	/* 1:Enable pf_write() */
-
-#define _FS_FAT12	1	/* 1:Enable FAT12 support */
-#define _FS_FAT32	1	/* 1:Enable FAT32 support */
-
-
-#define	_CODE_PAGE	1
-/* Defines which code page is used for path name. Supported code pages are:
-/  932, 936, 949, 950, 437, 720, 737, 775, 850, 852, 855, 857, 858, 862, 866,
-/  874, 1250, 1251, 1252, 1253, 1254, 1255, 1257, 1258 and 1 (ASCII only).
-/  SBCS code pages except for 1 requiers a case conversion table. This
-/  might occupy 128 bytes on the RAM on some platforms, e.g. avr-gcc. */
-
-
-#define _WORD_ACCESS	0
-/* The _WORD_ACCESS option defines which access method is used to the word
-/  data in the FAT structure.
-/
-/   0: Byte-by-byte access. Always compatible with all platforms.
-/   1: Word access. Do not choose this unless following condition is met.
-/
-/  When the byte order on the memory is big-endian or address miss-aligned
-/  word access results incorrect behavior, the _WORD_ACCESS must be set to 0.
-/  If it is not the case, the value can also be set to 1 to improve the
-/  performance and code efficiency. */
-
-
-/* End of configuration options. Do not change followings without care.     */
-/*--------------------------------------------------------------------------*/
-
-
-
-#if _FS_FAT32
-#define	CLUST	DWORD
-#else
-#define	CLUST	WORD
-#endif
-
-
-/* File system object structure */
-
-typedef struct {
-	BYTE	fs_type;	/* FAT sub type */
-	BYTE	flag;		/* File status flags */
-	BYTE	csize;		/* Number of sectors per cluster */
-	BYTE	pad1;
-	WORD	n_rootdir;	/* Number of root directory entries (0 on FAT32) */
-	CLUST	n_fatent;	/* Number of FAT entries (= number of clusters + 2) */
-	DWORD	fatbase;	/* FAT start sector */
-	DWORD	dirbase;	/* Root directory start sector (Cluster# on FAT32) */
-	DWORD	database;	/* Data start sector */
-	DWORD	fptr;		/* File R/W pointer */
-	DWORD	fsize;		/* File size */
-	CLUST	org_clust;	/* File start cluster */
-	CLUST	curr_clust;	/* File current cluster */
-	DWORD	dsect;		/* File current data sector */
-} FATFS;
-
-
-
-/* Directory object structure */
-
-typedef struct {
-	WORD	index;		/* Current read/write index number */
-	BYTE*	fn;			/* Pointer to the SFN (in/out) {file[8],ext[3],status[1]} */
-	CLUST	sclust;		/* Table start cluster (0:Static table) */
-	CLUST	clust;		/* Current cluster */
-	DWORD	sect;		/* Current sector */
-} DIR;
-
-
-
-/* File status structure */
-
-typedef struct {
-	DWORD	fsize;		/* File size */
-	WORD	fdate;		/* Last modified date */
-	WORD	ftime;		/* Last modified time */
-	BYTE	fattrib;	/* Attribute */
-	char	fname[13];	/* File name */
-} FILINFO;
-
-
-
-/* File function return code (FRESULT) */
-
-typedef enum {
-	FR_OK = 0,			/* 0 */
-	FR_DISK_ERR,		/* 1 */
-	FR_NOT_READY,		/* 2 */
-	FR_NO_FILE,			/* 3 */
-	FR_NO_PATH,			/* 4 */
-	FR_NOT_OPENED,		/* 5 */
-	FR_NOT_ENABLED,		/* 6 */
-	FR_NO_FILESYSTEM, /* 7 */
-  FR_FULL
-} FRESULT;
-
-
-
-/*--------------------------------------------------------------*/
-/* Petit FatFs module application interface                     */
-
-FRESULT pf_mount (FATFS*);						/* Mount/Unmount a logical drive */
-FRESULT pf_open (const char*);					/* Open a file */
-FRESULT pf_read (void*, WORD, WORD*);			/* Read data from the open file */
-FRESULT pf_write (const void*, WORD, WORD*);	/* Write data to the open file */
-FRESULT pf_lseek (DWORD);						/* Move file pointer of the open file */
-FRESULT pf_opendir (DIR*, const char*);			/* Open a directory */
-FRESULT pf_readdir (DIR*, FILINFO*);			/* Read a directory item from the open directory */
-
-
-
-/*--------------------------------------------------------------*/
-/* Flags and offset address                                     */
-
-/* File status flag (FATFS.flag) */
-
-#define	FA_OPENED	0x01
-#define	FA_WPRT		0x02
-#define	FA__WIP		0x40
-
-
-/* FAT sub type (FATFS.fs_type) */
-
-#define FS_FAT12	1
-#define FS_FAT16	2
-#define FS_FAT32	3
-
-
-/* File attribute bits for directory entry */
-
-#define	AM_RDO	0x01	/* Read only */
-#define	AM_HID	0x02	/* Hidden */
-#define	AM_SYS	0x04	/* System */
-#define	AM_VOL	0x08	/* Volume label */
-#define AM_LFN	0x0F	/* LFN entry */
-#define AM_DIR	0x10	/* Directory */
-#define AM_ARC	0x20	/* Archive */
-#define AM_MASK	0x3F	/* Mask of defined bits */
-
-
-/*--------------------------------*/
-/* Multi-byte word access macros  */
-
-#if _WORD_ACCESS == 1	/* Enable word access to the FAT structure */
-//#define	LD_WORD(ptr)		(WORD)(*((WORD*)((BYTE*)(ptr))))
-#define	LD_WORD(ptr)		(WORD)((((BYTE*) ptr)[1]<<8)|((BYTE*)ptr)[0])
-#define	LD_DWORD(ptr)		(DWORD)(*(DWORD*)(BYTE*)(ptr))
-#define	ST_WORD(ptr,val)	*(WORD*)(BYTE*)(ptr)=(WORD)(val)
-#define	ST_DWORD(ptr,val)	*(DWORD*)(BYTE*)(ptr)=(DWORD)(val)
-#else					/* Use byte-by-byte access to the FAT structure */
-#define	LD_WORD(ptr)		(WORD)((((BYTE*) ptr)[1]<<8)|((BYTE*)ptr)[0])
-#define	LD_DWORD(ptr)		(DWORD)((((BYTE*) ptr)[3]<<24)|(((BYTE*) ptr)[2]<<16)|(((BYTE*) ptr)[1]<<8)|((BYTE*)ptr)[0])
-#define	ST_WORD(ptr,val)	*(BYTE*)(ptr)=(BYTE)(val); *((BYTE*)(ptr)+1)=(BYTE)((WORD)(val)>>8)
-#define	ST_DWORD(ptr,val)	*(BYTE*)(ptr)=(BYTE)(val); *((BYTE*)(ptr)+1)=(BYTE)((WORD)(val)>>8); *((BYTE*)(ptr)+2)=(BYTE)((DWORD)(val)>>16); *((BYTE*)(ptr)+3)=(BYTE)((DWORD)(val)>>24)
-#endif
-
-
-#endif /* _FATFS */
diff --git a/platform/jnode/sd.c b/platform/jnode/sd.c
deleted file mode 100644
index 8822fe2..0000000
--- a/platform/jnode/sd.c
+++ /dev/null
@@ -1,464 +0,0 @@
-/*-----------------------------------------------------------------------*/
-/* Low level disk I/O module skeleton for Petit FatFs (C)ChaN, 2009      */
-/*-----------------------------------------------------------------------*/
-
-#include "pff.h"
-#include "sd.h"
-#include "AppHardwareApi.h"
-
-#define LOWER_CS() do { vAHI_SpiWaitBusy(); vAHI_SpiSelect(1<<1); vAHI_SpiWaitBusy(); } while(0)
-#define RAISE_CS() do { vAHI_SpiWaitBusy(); vAHI_SpiSelect(0); vAHI_SpiWaitBusy(); } while(0)
-
-/*-----------------------------------------------------------------------*/
-/* Initialize Disk Drive                                                 */
-/*-----------------------------------------------------------------------*/
-
-#define DEBUG 0
-
-#include <stdio.h>
-#if DEBUG != 0
-#define PRINTF(...) printf(__VA_ARGS__)
-#else
-#define PRINTF(...)
-#endif
-
-#ifndef MIN
-#define MIN(a, b)_((a) < (b) ? (a) : (b))
-#endif /* MIN */
-
-#define SDCARD_SLAVE E_AHI_SPIM_SLAVE_ENBLE_0
-
-/* SD commands */
-#define GO_IDLE_STATE     0
-#define SEND_OP_COND      1
-#define SWITCH_FUNC       6
-#define SEND_IF_COND      8
-#define SEND_CSD          9
-#define SEND_CID          10
-#define STOP_TRANSMISSION 12
-#define SEND_STATUS       13
-#define READ_SINGLE_BLOCK 17
-#define WRITE_BLOCK       24
-#define READ_OCR          58
-#define SPI_IDLE          0xff
-
-/* SD response lengths. */
-#define R1 1
-#define R2 2
-#define R3 5
-#define R7 5
-
-#define START_BLOCK_TOKEN 0xfe
-
-/* Status codes returned after writing a block. */
-#define DATA_ACCEPTED 2
-#define DATA_CRC_ERROR 5
-#define DATA_WRITE_ERROR 6
-
-#define SD_TRANSACTION_ATTEMPTS		512
-#define SD_READ_RESPONSE_ATTEMPTS	8
-#define SD_READ_BLOCK_ATTEMPTS		2
-
-#define SD_DEFAULT_BLOCK_SIZE			512
-
-static uint16_t rw_block_size,
-                block_size;
-
-static int
-send_command(uint8_t cmd, uint32_t argument)
-{
-  uint8_t req[6], i;
-
-  req[0] = 0x40 | cmd;
-  req[1] = argument >> 24;
-  req[2] = argument >> 16;
-  req[3] = argument >> 8;
-  req[4] = argument;
-  /* The CRC hard-wired to 0x95 is only needed for the initial 
-     GO_IDLE_STATE command. */
-  req[5] = 0x95;
-
-  vAHI_SpiWaitBusy(); vAHI_SpiStartTransfer8(SPI_IDLE);
-  for (i=0; i<sizeof(req); i++) {
-    vAHI_SpiWaitBusy(); vAHI_SpiStartTransfer8(req[i]);
-  }
-  vAHI_SpiWaitBusy(); vAHI_SpiStartTransfer8(SPI_IDLE);
-
-  PRINTF("send command: %d %d %d %d %d %d\n", req[0]-0x40,req[1],req[2],req[3],req[4],req[5]);
-
-  return 0;
-}
-/*---------------------------------------------------------------------------*/
-static uint8_t *
-get_response(int length)
-{
-  int i;
-  int x;
-  static uint8_t r[R7];
-
-  for(i = 0; i < SD_READ_RESPONSE_ATTEMPTS; i++) {
-    vAHI_SpiStartTransfer8(0xff);
-    vAHI_SpiWaitBusy();
-    x = u8AHI_SpiReadTransfer8();
-
-    if((x & 0x80) == 0) {
-      /* A get_response byte is indicated by the MSB being 0. */
-      r[0] = x;
-      break;
-    }
-  }
-
-  if(i == SD_READ_RESPONSE_ATTEMPTS) {
-    PRINTF("get_response: timeout");
-    return NULL;
-  }
-
-  for(i = 1; i < length; i++) {
-    vAHI_SpiStartTransfer8(0xff);
-    vAHI_SpiWaitBusy();
-    r[i] = u8AHI_SpiReadTransfer8();
-  }
-
-  PRINTF("get_response %d", r[0]);
-
-  return r;
-}
-/*---------------------------------------------------------------------------*/
-static unsigned char *
-transaction(int command, unsigned long argument,
-  int response_type, unsigned attempts)
-{
-  unsigned i;
-  unsigned char *r;
-
-  r = NULL;
-  for(i = 0; i < attempts; i++) {
-    LOWER_CS();
-    send_command(command, argument);
-    r = get_response(response_type);
-    RAISE_CS();
-    if(r != NULL) {
-      break;
-    }
-  }
-
-  return r;
-}
-
-static enum { IDLE=0x00,TRANSMIT  } write_state = IDLE;
-DRESULT
-disk_readp2(
-  int read_cmd,
-  BYTE *dest,
-  DWORD sect,
-  DWORD offset,
-  WORD count)
-{
-  unsigned char *r = NULL;
-  int retval = RES_ERROR, i, token;
-
-  if (write_state==TRANSMIT) {
-    PRINTF("sd: read failed, write transaction in progress\n");
-    return RES_NOTRDY;
-  }
-
-  PRINTF("disk_readp(%d,0x%x,%d,%d,%d)==",read_cmd, dest,sect,offset,count);
-
-  if (read_cmd==READ_SINGLE_BLOCK && offset+count > rw_block_size) {
-    PRINTF("attempting to read block (%d) bigger than rw_block_size (%d)!!"
-       ,offset+count,rw_block_size);
-    return 0;
-  }
-
-  /* try and send the read command */
-  for(i = 0; i < SD_TRANSACTION_ATTEMPTS; i++) {
-    LOWER_CS();
-    send_command(read_cmd, sect*rw_block_size);
-    r = get_response(R1);
-    if(r != NULL && r[0]==0) {
-      break;
-    }
-    RAISE_CS();
-  }
-
-  if (r==NULL || r[0]!=0) {
-    PRINTF("error during read");
-    RAISE_CS();
-    return RES_ERROR;
-  }
-
-  /* We received an R1 response with no errors.
-     Get a token from the card now. */
-  for(i = 0; i < SD_TRANSACTION_ATTEMPTS; i++) {
-    vAHI_SpiWaitBusy();
-    vAHI_SpiStartTransfer8(0xff);
-    vAHI_SpiWaitBusy();
-    token = u8AHI_SpiReadTransfer8();
-    if(token == START_BLOCK_TOKEN || (token > 0 && token <= 8))
-      break;
-  }
-
-  PRINTF("returned read token: %d (%d attemtps)\n", token, i);
-
-  if(token == START_BLOCK_TOKEN) {
-    /* consume the offset */
-    for(i=0; i<offset; i++) {
-      vAHI_SpiStartTransfer8(0x00);
-      vAHI_SpiWaitBusy();
-      u8AHI_SpiReadTransfer8();
-    }
-
-    /* A start block token has been received. Read the block now. */
-    for(i=0; i<count; i++) {
-      vAHI_SpiStartTransfer8(0x00);
-      vAHI_SpiWaitBusy();
-      dest[i] = u8AHI_SpiReadTransfer8();
-    }
-
-    /* consume what is left of the block 
-     * XXX: might wanna send STOP_COND here instead of consuming whole block */
-    if (read_cmd==READ_SINGLE_BLOCK)
-      for (i=0; i<(rw_block_size-offset-count); i++) {
-        vAHI_SpiStartTransfer8(0x00);
-        vAHI_SpiWaitBusy();
-      }
-
-    /* Consume CRC. TODO: Validate the block. */
-    vAHI_SpiStartTransfer8(0x00); vAHI_SpiWaitBusy();
-    vAHI_SpiStartTransfer8(0x00); vAHI_SpiWaitBusy();
-
-    retval = RES_OK;
-  } else if(token > 0 && token <= 8) {
-    /* The card returned a data error token. */
-    retval = RES_ERROR;
-    if (retval & (1<<0))
-      PRINTF("General Error\n");
-    else if (retval & (1<<1))
-      PRINTF("Internal card controller error\n");
-    else if (retval & (1<<2))
-      PRINTF("Card ECC error\n");
-    else if (retval & (1<<3))
-      PRINTF("Out of Range\n");
-  } else {
-    /* The card never returned a token after our read attempts. */
-    retval = RES_NOTRDY;
-    PRINTF("no returned read token\n");
-  }
-
-  RAISE_CS();
-  return retval;
-}
-
-
-static int
-read_register(int register_cmd, char *buf, int register_size)
-{
-  return disk_readp2(register_cmd, buf, 0, 0, register_size);
-}
-
-
-/*-----------------------------------------------------------------------*/
-/* Read Partial Sector                                                   */
-/*-----------------------------------------------------------------------*/
-
-DRESULT
-disk_readp(BYTE *dest, DWORD src, WORD offset, WORD count)
-{
-  return disk_readp2(READ_SINGLE_BLOCK, dest, src, offset, count);
-}
-
-
-/*-----------------------------------------------------------------------*/
-/* Write Partial Sector                                                  */
-/*-----------------------------------------------------------------------*/
-
-DRESULT disk_writep (
-  const BYTE* buff,   /* Pointer to the data to be written, NULL:Initiate/Finalize write operation */
-  DWORD sc            /* Sector number (LBA) or Number of bytes to send */
-)
-{
-  DRESULT res;
-  uint8_t* r, data_response, status_code;
-  uint16_t i;
-  static uint16_t d;
-
-  PRINTF("disk_writep(buff=0x%x, sc=%d)\n", buff, sc);
-
-  if (!buff) {
-    if (sc) { // initialize write process
-      for(i = 0; i < SD_TRANSACTION_ATTEMPTS; i++) {
-        if (write_state != IDLE) {
-          PRINTF("sd: initialize write, write transaction already in progress\n");
-          return RES_NOTRDY;
-        }
-        LOWER_CS();
-        send_command(WRITE_BLOCK, sc*rw_block_size);
-        r = get_response(R1);
-        if(r != NULL && r[0] == 0) {
-          PRINTF("write request OK\n");
-          break;
-        }
-        RAISE_CS();
-      }
-
-      if (r==0) {
-        PRINTF("no response to write request\n");
-        return RES_NOTRDY;
-      }
-
-      /* re-select card and wait to transmit data */
-      LOWER_CS();
-
-      vAHI_SpiWaitBusy();
-      vAHI_SpiStartTransfer8(START_BLOCK_TOKEN);
-      vAHI_SpiWaitBusy();
-
-      write_state = TRANSMIT;
-      d=0;
-
-      return RES_OK;
-    } else {  // finalize write process
-      if (write_state != TRANSMIT) {
-        PRINTF("sd: finalize error, write transaction not started\n");
-        return RES_NOTRDY;
-      }
-
-      PRINTF("finalizing write request after %d bytes",d);
-
-      for(i=0;i<SD_TRANSACTION_ATTEMPTS*10; i++) {
-        vAHI_SpiStartTransfer8(SPI_IDLE);
-        vAHI_SpiWaitBusy();
-        data_response = u8AHI_SpiReadTransfer8();
-        if((data_response & 0x11) == 1) {
-          /* Data response token received. */
-          status_code = (data_response >> 1) & 0x7;
-          if(status_code == DATA_ACCEPTED) {
-            PRINTF(" OK (%d tries)\n", i);
-            res = RES_OK;
-            break;
-          } else {
-            PRINTF(" ERROR (%d tries)\n", i);
-            res = RES_ERROR;
-            break;
-          }
-        }
-      }
-
-      /* wait until card is idle */
-      while (u8AHI_SpiReadTransfer8()!=SPI_IDLE) {
-        vAHI_SpiStartTransfer8(SPI_IDLE);
-        vAHI_SpiWaitBusy();
-      }
-
-      if (i==SD_TRANSACTION_ATTEMPTS)
-        PRINTF(" ERROR (timeout %d tries)\n", i);
-
-      RAISE_CS();
-      write_state = IDLE;
-    }
-  } else { // Send data to the disk
-    if (write_state!=TRANSMIT) {
-      PRINTF("sd: write, transaction not started\n");
-      return RES_NOTRDY;
-    }
-
-    for (i=0;i<sc; i++)
-    {
-      vAHI_SpiWaitBusy();
-      vAHI_SpiStartTransfer8(buff[i]);
-    }
-
-    d+=sc;
-    return RES_OK;
-  }
-
-  return res;
-}
-
-
-DSTATUS
-disk_initialize (void)
-{
-  uint8_t *r=NULL, reg[16], read_bl_len;
-  uint16_t i;
-
-  /* init with slow SPI speed */
-  vAHI_SpiConfigure(2,   // number of spi slave select line
-                    E_AHI_SPIM_MSB_FIRST,
-                    0,0, // polarity and phase
-                    400,   // clock divisor, 8Mhz clock
-                    E_AHI_SPIM_INT_DISABLE,
-                    E_AHI_SPIM_AUTOSLAVE_DSABL);
-
-  LOWER_CS();
-  for (i=0;i<100; i++)
-  { // initialize card by sending some clocks
-    vAHI_SpiStartTransfer8(0xff);
-    vAHI_SpiWaitBusy();
-  }
-  RAISE_CS();
-
-  r = transaction(GO_IDLE_STATE, 0, R1, SD_TRANSACTION_ATTEMPTS);
-  if(r != NULL) {
-    PRINTF("Go-idle result: %d\n", r[0]);
-  } else {
-    PRINTF("Failed to get go-idle response\n");
-    return STA_NOINIT;
-  }
-
-  LOWER_CS();
-  for(i = 0; i < SD_TRANSACTION_ATTEMPTS; i++) {
-    send_command(SEND_OP_COND, 0);
-    r = get_response(R1);
-    if(r != NULL && !(r[0] & 1)) {
-      break;
-    }
-  }
-  RAISE_CS();
-
-  if(r != NULL) {
-    PRINTF("OP cond: %d (%d iterations)\n", r[0], i);
-  } else {
-    PRINTF("Failed to get OP cond get_response\n");
-  }
-
-  for(i = 0; i < SD_TRANSACTION_ATTEMPTS; i++) {
-    LOWER_CS();
-    send_command(READ_OCR, 0);
-    r = get_response(R3);
-    RAISE_CS();
-    if(r != NULL) {
-      break;
-    }
-  }
-
-  if(r != NULL) {
-    PRINTF("OCR: %d %d %d %d %d\n", r[0], r[1], r[2], r[3], r[4]);
-  }
-
-  if(read_register(SEND_CSD, reg, sizeof(reg)) < 0) {
-    PRINTF("Failed to get block size of SD card\n");
-    return STA_NOINIT;
-  }
-
-  read_bl_len = reg[5] & 0x0f;
-  block_size = 1 << read_bl_len;
-  rw_block_size = (block_size > SD_DEFAULT_BLOCK_SIZE) ?
-                   SD_DEFAULT_BLOCK_SIZE : block_size;
-
-  PRINTF("Found block size %d\n", block_size);
-
-  /* XXX Arbitrary wait time here. Need to investigate why this is needed. */
-  clock_delay(CLOCK_SECOND/200);
-
-  /* continue at high speed */
-  vAHI_SpiConfigure(2,   // number of spi slave select line
-                    E_AHI_SPIM_MSB_FIRST,
-                    0,0, // polarity and phase
-                    1,   // clock divisor, 8Mhz clock
-                    E_AHI_SPIM_INT_DISABLE,
-                    E_AHI_SPIM_AUTOSLAVE_DSABL);
-
-
-  return 0;
-}
diff --git a/platform/jnode/sd.h b/platform/jnode/sd.h
deleted file mode 100644
index b3957e2..0000000
--- a/platform/jnode/sd.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/*-----------------------------------------------------------------------
-/  PFF - Low level disk interface modlue include file    (C)ChaN, 2009
-/-----------------------------------------------------------------------*/
-
-#ifndef __SD_H__
-# include "pff.h"
-
-
-/* Status of Disk Functions */
-typedef BYTE	DSTATUS;
-
-
-/* Results of Disk Functions */
-typedef enum {
-	RES_OK = 0,		/* 0: Function succeeded */
-	RES_ERROR,		/* 1: Disk error */
-	RES_NOTRDY,		/* 2: Not ready */
-	RES_PARERR		/* 3: Invalid parameter */
-} DRESULT;
-
-
-/*---------------------------------------*/
-/* Prototypes for disk control functions */
-
-DSTATUS disk_initialize (void);
-DRESULT disk_readp (BYTE*, DWORD, WORD, WORD);
-DRESULT disk_writep (const BYTE*, DWORD);
-
-#define STA_NOINIT		0x01	/* Drive not initialized */
-#define STA_NODISK		0x02	/* No medium in the drive */
-
-/* Card type flags (CardType) */
-#define CT_MMC				0x01	/* MMC ver 3 */
-#define CT_SD1				0x02	/* SD ver 1 */
-#define CT_SD2				0x04	/* SD ver 2 */
-#define CT_SDC				(CT_SD1|CT_SD2)	/* SD */
-#define CT_BLOCK			0x08	/* Block addressing */
-
-#define __SD_H__
-#endif
